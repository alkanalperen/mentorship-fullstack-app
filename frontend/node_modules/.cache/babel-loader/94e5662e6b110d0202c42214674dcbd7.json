{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = require(\"./lib/renamer\");\n\nvar _index = require(\"../index\");\n\nvar _binding = require(\"./binding\");\n\nvar _globals = require(\"globals\");\n\nvar t = require(\"@babel/types\");\n\nvar _cache = require(\"../cache\");\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (t.isModuleDeclaration(node)) {\n        if ((t.isExportAllDeclaration(node) || t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((t.isExportDefaultDeclaration(node) || t.isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (t.isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (t.isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  For(path) {\n    for (const key of t.FOR_INIT_KEYS) {\n      const declar = path.get(key);\n\n      if (declar.isVar()) {\n        const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        parentScope.registerBinding(\"var\", declar);\n      }\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isImportDeclaration()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ImportDeclaration(path) {\n    const parent = path.scope.getBlockParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (t.isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        if (binding) binding.reference(path);\n      } else if (t.isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(t.getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            if (binding) binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const isKey = path.key === \"key\";\n      path = path.parentPath;\n      if (isKey && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return t.cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return t.identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = t.toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return t.identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (t.isThisExpression(node) || t.isSuper(node)) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return t.cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (t.isArrayExpression(node)) {\n      return node;\n    }\n\n    if (t.isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(\"Array\"), t.identifier(\"prototype\")), t.identifier(\"slice\")), t.identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(t.numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return t.callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return t.unaryExpression(\"void\", t.numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (t.isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (t.isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (t.isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (t.isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (t.isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (t.isTaggedTemplateExpression(node)) {\n      return t.matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (t.isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return t.isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = t.variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = t.variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind(...kinds) {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\") {} else {\n          return binding;\n        }\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","map":{"version":3,"sources":["/Users/alperenalkan/obss/frontend/frontend/node_modules/@babel/traverse/lib/scope/index.js"],"names":["Object","defineProperty","exports","value","default","_renamer","require","_index","_binding","_globals","t","_cache","gatherNodeParts","node","parts","type","isModuleDeclaration","isExportAllDeclaration","isExportNamedDeclaration","isImportDeclaration","source","specifiers","length","e","isExportDefaultDeclaration","declaration","isModuleSpecifier","local","isLiteral","push","object","property","name","callee","properties","argument","key","left","id","expression","meta","openingElement","openingFragment","namespace","collectorVisitor","For","path","FOR_INIT_KEYS","declar","get","isVar","parentScope","scope","getFunctionParent","getProgramParent","registerBinding","Declaration","isBlockScoped","isExportDeclaration","parent","registerDeclaration","ImportDeclaration","getBlockParent","ReferencedIdentifier","state","references","ForXStatement","isPattern","isIdentifier","constantViolations","ExportDeclaration","exit","isClassDeclaration","isFunctionDeclaration","binding","getBinding","reference","isVariableDeclaration","decl","declarations","keys","getBindingIdentifiers","LabeledStatement","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","BlockScoped","bindings","CatchClause","Function","isFunctionExpression","has","NOT_LOCAL_BINDING","params","param","ClassExpression","uid","Scope","constructor","block","labels","inited","globals","uids","data","crawling","cached","set","Map","_parent","isKey","parentPath","isMethod","isScope","parentBlock","hub","traverse","opts","generateDeclaredUidIdentifier","generateUidIdentifier","cloneNode","identifier","generateUid","toIdentifier","replace","i","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","generateUidBasedOnNode","defaultName","join","slice","generateUidIdentifierBasedOnNode","isStatic","isThisExpression","isSuper","constant","maybeGenerateMemoised","dontPush","checkBlockScopedCollisions","kind","duplicate","buildError","TypeError","rename","oldName","newName","_renameFromMap","map","dump","sep","repeat","console","log","violations","toArray","arrayLikeIsIterable","isGenericType","isArrayExpression","callExpression","memberExpression","helperName","args","numericLiteral","unshift","addHelper","getLabel","registerLabel","label","isLabeledStatement","specifier","buildUndefinedNode","unaryExpression","registerConstantViolation","ids","reassign","bindingPath","ReferenceError","declarators","getOuterBindingIdentifiers","getOwnBinding","addGlobal","hasUid","isPure","constantsOnly","isClass","superClass","body","isClassBody","method","isBinary","right","elem","elements","isObjectExpression","prop","computed","isProperty","isUnaryExpression","isTaggedTemplateExpression","matchesPattern","tag","quasi","isTemplateLiteral","expressions","isPureish","setData","val","getData","removeData","init","crawl","create","programParent","_exploded","visit","enter","typeVisitors","ref","isBlockStatement","isProgram","isSwitchStatement","isLoop","isCatchClause","isFunction","ensureBlock","unique","blockHoist","_blockHoist","dataKey","declarPath","variableDeclaration","unshiftContainer","declarator","variableDeclarator","pop","Error","isFunctionParent","isBlockParent","getAllBindings","getAllBindingsOfKind","kinds","bindingIdentifierEquals","getBindingIdentifier","previousPath","_previousPath","_this$getBinding","getOwnBindingIdentifier","hasOwnBinding","noGlobals","parentHasBinding","includes","contextVariables","_this$parent","moveBindingTo","info","removeOwnBinding","removeBinding","_this$getBinding2","builtin"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = require(\"./lib/renamer\");\n\nvar _index = require(\"../index\");\n\nvar _binding = require(\"./binding\");\n\nvar _globals = require(\"globals\");\n\nvar t = require(\"@babel/types\");\n\nvar _cache = require(\"../cache\");\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (t.isModuleDeclaration(node)) {\n        if ((t.isExportAllDeclaration(node) || t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((t.isExportNamedDeclaration(node) || t.isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((t.isExportDefaultDeclaration(node) || t.isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (t.isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (t.isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  For(path) {\n    for (const key of t.FOR_INIT_KEYS) {\n      const declar = path.get(key);\n\n      if (declar.isVar()) {\n        const parentScope = path.scope.getFunctionParent() || path.scope.getProgramParent();\n        parentScope.registerBinding(\"var\", declar);\n      }\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isImportDeclaration()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ImportDeclaration(path) {\n    const parent = path.scope.getBlockParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (t.isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (t.isClassDeclaration(declar) || t.isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        if (binding) binding.reference(path);\n      } else if (t.isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(t.getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            if (binding) binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[t.NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const isKey = path.key === \"key\";\n      path = path.parentPath;\n      if (isKey && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return t.cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return t.identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = t.toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return t.identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (t.isThisExpression(node) || t.isSuper(node)) {\n      return true;\n    }\n\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return t.cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (t.isArrayExpression(node)) {\n      return node;\n    }\n\n    if (t.isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return t.callExpression(t.memberExpression(t.memberExpression(t.memberExpression(t.identifier(\"Array\"), t.identifier(\"prototype\")), t.identifier(\"slice\")), t.identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(t.numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return t.callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return t.unaryExpression(\"void\", t.numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (t.isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (t.isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (t.isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (t.isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (t.isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (t.isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (t.isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (t.isTaggedTemplateExpression(node)) {\n      return t.matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (t.isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return t.isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = t.variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = t.variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind(...kinds) {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\") {} else {\n          return binding;\n        }\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];"]},"metadata":{},"sourceType":"script"}