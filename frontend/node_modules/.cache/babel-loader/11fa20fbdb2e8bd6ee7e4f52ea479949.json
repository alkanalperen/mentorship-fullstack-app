{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = literalTemplate;\n\nvar _options = require(\"./options\");\n\nvar _parse = require(\"./parse\");\n\nvar _populate = require(\"./populate\");\n\nfunction literalTemplate(formatter, tpl, opts) {\n  const {\n    metadata,\n    names\n  } = buildLiteralData(formatter, tpl, opts);\n  return arg => {\n    const defaultReplacements = {};\n    arg.forEach((replacement, i) => {\n      defaultReplacements[names[i]] = replacement;\n    });\n    return arg => {\n      const replacements = (0, _options.normalizeReplacements)(arg);\n\n      if (replacements) {\n        Object.keys(replacements).forEach(key => {\n          if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {\n            throw new Error(\"Unexpected replacement overlap.\");\n          }\n        });\n      }\n\n      return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));\n    };\n  };\n}\n\nfunction buildLiteralData(formatter, tpl, opts) {\n  let names;\n  let nameSet;\n  let metadata;\n  let prefix = \"\";\n\n  do {\n    prefix += \"$\";\n    const result = buildTemplateCode(tpl, prefix);\n    names = result.names;\n    nameSet = new Set(names);\n    metadata = (0, _parse.default)(formatter, formatter.code(result.code), {\n      parser: opts.parser,\n      placeholderWhitelist: new Set(result.names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),\n      placeholderPattern: opts.placeholderPattern,\n      preserveComments: opts.preserveComments,\n      syntacticPlaceholders: opts.syntacticPlaceholders\n    });\n  } while (metadata.placeholders.some(placeholder => placeholder.isDuplicate && nameSet.has(placeholder.name)));\n\n  return {\n    metadata,\n    names\n  };\n}\n\nfunction buildTemplateCode(tpl, prefix) {\n  const names = [];\n  let code = tpl[0];\n\n  for (let i = 1; i < tpl.length; i++) {\n    const value = `${prefix}${i - 1}`;\n    names.push(value);\n    code += value + tpl[i];\n  }\n\n  return {\n    names,\n    code\n  };\n}","map":{"version":3,"sources":["/Users/alperenalkan/obss/frontend/frontend/node_modules/@babel/template/lib/literal.js"],"names":["Object","defineProperty","exports","value","default","literalTemplate","_options","require","_parse","_populate","formatter","tpl","opts","metadata","names","buildLiteralData","arg","defaultReplacements","forEach","replacement","i","replacements","normalizeReplacements","keys","key","prototype","hasOwnProperty","call","Error","unwrap","assign","nameSet","prefix","result","buildTemplateCode","Set","code","parser","placeholderWhitelist","concat","Array","from","placeholderPattern","preserveComments","syntacticPlaceholders","placeholders","some","placeholder","isDuplicate","has","name","length","push"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = literalTemplate;\n\nvar _options = require(\"./options\");\n\nvar _parse = require(\"./parse\");\n\nvar _populate = require(\"./populate\");\n\nfunction literalTemplate(formatter, tpl, opts) {\n  const {\n    metadata,\n    names\n  } = buildLiteralData(formatter, tpl, opts);\n  return arg => {\n    const defaultReplacements = {};\n    arg.forEach((replacement, i) => {\n      defaultReplacements[names[i]] = replacement;\n    });\n    return arg => {\n      const replacements = (0, _options.normalizeReplacements)(arg);\n\n      if (replacements) {\n        Object.keys(replacements).forEach(key => {\n          if (Object.prototype.hasOwnProperty.call(defaultReplacements, key)) {\n            throw new Error(\"Unexpected replacement overlap.\");\n          }\n        });\n      }\n\n      return formatter.unwrap((0, _populate.default)(metadata, replacements ? Object.assign(replacements, defaultReplacements) : defaultReplacements));\n    };\n  };\n}\n\nfunction buildLiteralData(formatter, tpl, opts) {\n  let names;\n  let nameSet;\n  let metadata;\n  let prefix = \"\";\n\n  do {\n    prefix += \"$\";\n    const result = buildTemplateCode(tpl, prefix);\n    names = result.names;\n    nameSet = new Set(names);\n    metadata = (0, _parse.default)(formatter, formatter.code(result.code), {\n      parser: opts.parser,\n      placeholderWhitelist: new Set(result.names.concat(opts.placeholderWhitelist ? Array.from(opts.placeholderWhitelist) : [])),\n      placeholderPattern: opts.placeholderPattern,\n      preserveComments: opts.preserveComments,\n      syntacticPlaceholders: opts.syntacticPlaceholders\n    });\n  } while (metadata.placeholders.some(placeholder => placeholder.isDuplicate && nameSet.has(placeholder.name)));\n\n  return {\n    metadata,\n    names\n  };\n}\n\nfunction buildTemplateCode(tpl, prefix) {\n  const names = [];\n  let code = tpl[0];\n\n  for (let i = 1; i < tpl.length; i++) {\n    const value = `${prefix}${i - 1}`;\n    names.push(value);\n    code += value + tpl[i];\n  }\n\n  return {\n    names,\n    code\n  };\n}"]},"metadata":{},"sourceType":"script"}