{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar t = require(\"@babel/types\");\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(types);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(types);\n  }\n\n  return t.createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return t.createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n      return {\n        typeAnnotation: t.createTSUnionType(types),\n        ifStatement\n      };\n    }\n\n    if (t.createFlowUnionType) {\n      return {\n        typeAnnotation: t.createFlowUnionType(types),\n        ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}","map":{"version":3,"sources":["/Users/alperenalkan/obss/frontend/frontend/node_modules/@babel/traverse/lib/path/inference/inferer-reference.js"],"names":["Object","defineProperty","exports","value","default","_default","t","require","node","isReferenced","binding","scope","getBinding","name","identifier","typeAnnotation","getTypeAnnotationBindingConstantViolations","voidTypeAnnotation","numberTypeAnnotation","path","types","functionConstantViolations","constantViolations","getConstantViolationsBefore","testType","getConditionalAnnotation","testConstantViolations","ifStatement","filter","indexOf","push","length","concat","violation","getTypeAnnotation","isTSTypeAnnotation","createTSUnionType","createFlowUnionType","createUnionTypeAnnotation","functions","violations","slice","unshift","resolve","status","_guessExecutionStatusRelativeTo","inferAnnotationFromBinaryExpression","operator","right","get","left","target","isIdentifier","BOOLEAN_NUMBER_BINARY_OPERATORS","typeofPath","typePath","isUnaryExpression","isLiteral","typeValue","createTypeAnnotationBasedOnTypeof","getParentConditionalPath","parentPath","isIfStatement","isConditionalExpression","key","isFunction","test","paths","i","isLogicalExpression","isBinaryExpression","type"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar t = require(\"@babel/types\");\n\nfunction _default(node) {\n  if (!this.isReferenced()) return;\n  const binding = this.scope.getBinding(node.name);\n\n  if (binding) {\n    if (binding.identifier.typeAnnotation) {\n      return binding.identifier.typeAnnotation;\n    } else {\n      return getTypeAnnotationBindingConstantViolations(binding, this, node.name);\n    }\n  }\n\n  if (node.name === \"undefined\") {\n    return t.voidTypeAnnotation();\n  } else if (node.name === \"NaN\" || node.name === \"Infinity\") {\n    return t.numberTypeAnnotation();\n  } else if (node.name === \"arguments\") {}\n}\n\nfunction getTypeAnnotationBindingConstantViolations(binding, path, name) {\n  const types = [];\n  const functionConstantViolations = [];\n  let constantViolations = getConstantViolationsBefore(binding, path, functionConstantViolations);\n  const testType = getConditionalAnnotation(binding, path, name);\n\n  if (testType) {\n    const testConstantViolations = getConstantViolationsBefore(binding, testType.ifStatement);\n    constantViolations = constantViolations.filter(path => testConstantViolations.indexOf(path) < 0);\n    types.push(testType.typeAnnotation);\n  }\n\n  if (constantViolations.length) {\n    constantViolations = constantViolations.concat(functionConstantViolations);\n\n    for (const violation of constantViolations) {\n      types.push(violation.getTypeAnnotation());\n    }\n  }\n\n  if (!types.length) {\n    return;\n  }\n\n  if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n    return t.createTSUnionType(types);\n  }\n\n  if (t.createFlowUnionType) {\n    return t.createFlowUnionType(types);\n  }\n\n  return t.createUnionTypeAnnotation(types);\n}\n\nfunction getConstantViolationsBefore(binding, path, functions) {\n  const violations = binding.constantViolations.slice();\n  violations.unshift(binding.path);\n  return violations.filter(violation => {\n    violation = violation.resolve();\n\n    const status = violation._guessExecutionStatusRelativeTo(path);\n\n    if (functions && status === \"unknown\") functions.push(violation);\n    return status === \"before\";\n  });\n}\n\nfunction inferAnnotationFromBinaryExpression(name, path) {\n  const operator = path.node.operator;\n  const right = path.get(\"right\").resolve();\n  const left = path.get(\"left\").resolve();\n  let target;\n\n  if (left.isIdentifier({\n    name\n  })) {\n    target = right;\n  } else if (right.isIdentifier({\n    name\n  })) {\n    target = left;\n  }\n\n  if (target) {\n    if (operator === \"===\") {\n      return target.getTypeAnnotation();\n    }\n\n    if (t.BOOLEAN_NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n      return t.numberTypeAnnotation();\n    }\n\n    return;\n  }\n\n  if (operator !== \"===\" && operator !== \"==\") return;\n  let typeofPath;\n  let typePath;\n\n  if (left.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = left;\n    typePath = right;\n  } else if (right.isUnaryExpression({\n    operator: \"typeof\"\n  })) {\n    typeofPath = right;\n    typePath = left;\n  }\n\n  if (!typeofPath) return;\n  if (!typeofPath.get(\"argument\").isIdentifier({\n    name\n  })) return;\n  typePath = typePath.resolve();\n  if (!typePath.isLiteral()) return;\n  const typeValue = typePath.node.value;\n  if (typeof typeValue !== \"string\") return;\n  return t.createTypeAnnotationBasedOnTypeof(typeValue);\n}\n\nfunction getParentConditionalPath(binding, path, name) {\n  let parentPath;\n\n  while (parentPath = path.parentPath) {\n    if (parentPath.isIfStatement() || parentPath.isConditionalExpression()) {\n      if (path.key === \"test\") {\n        return;\n      }\n\n      return parentPath;\n    }\n\n    if (parentPath.isFunction()) {\n      if (parentPath.parentPath.scope.getBinding(name) !== binding) return;\n    }\n\n    path = parentPath;\n  }\n}\n\nfunction getConditionalAnnotation(binding, path, name) {\n  const ifStatement = getParentConditionalPath(binding, path, name);\n  if (!ifStatement) return;\n  const test = ifStatement.get(\"test\");\n  const paths = [test];\n  const types = [];\n\n  for (let i = 0; i < paths.length; i++) {\n    const path = paths[i];\n\n    if (path.isLogicalExpression()) {\n      if (path.node.operator === \"&&\") {\n        paths.push(path.get(\"left\"));\n        paths.push(path.get(\"right\"));\n      }\n    } else if (path.isBinaryExpression()) {\n      const type = inferAnnotationFromBinaryExpression(name, path);\n      if (type) types.push(type);\n    }\n  }\n\n  if (types.length) {\n    if (t.isTSTypeAnnotation(types[0]) && t.createTSUnionType) {\n      return {\n        typeAnnotation: t.createTSUnionType(types),\n        ifStatement\n      };\n    }\n\n    if (t.createFlowUnionType) {\n      return {\n        typeAnnotation: t.createFlowUnionType(types),\n        ifStatement\n      };\n    }\n\n    return {\n      typeAnnotation: t.createUnionTypeAnnotation(types),\n      ifStatement\n    };\n  }\n\n  return getConditionalAnnotation(ifStatement, name);\n}"]},"metadata":{},"sourceType":"script"}