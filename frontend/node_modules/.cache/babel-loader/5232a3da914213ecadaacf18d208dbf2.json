{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _buffer = require(\"./buffer\");\n\nvar n = require(\"./node\");\n\nvar t = require(\"@babel/types\");\n\nvar generatorFunctions = require(\"./generators\");\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst NON_DECIMAL_LITERAL = /^0[box]/;\nconst PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\nconst {\n  isProgram,\n  isFile,\n  isEmptyStatement\n} = t;\nconst {\n  needsParens,\n  needsWhitespaceAfter,\n  needsWhitespaceBefore\n} = n;\n\nclass Printer {\n  constructor(format, map) {\n    this.inForStatementInitCounter = 0;\n    this._printStack = [];\n    this._indent = 0;\n    this._insideAux = false;\n    this._parenPushNewlineState = null;\n    this._noLineTerminator = false;\n    this._printAuxAfterOnNextUserNode = false;\n    this._printedComments = new WeakSet();\n    this._endsWithInteger = false;\n    this._endsWithWord = false;\n    this.format = format;\n    this._buf = new _buffer.default(map);\n  }\n\n  generate(ast) {\n    this.print(ast);\n\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  indent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent++;\n  }\n\n  dedent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent--;\n  }\n\n  semicolon(force = false) {\n    this._maybeAddAuxComment();\n\n    this._append(\";\", !force);\n  }\n\n  rightBrace() {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n\n    this.token(\"}\");\n  }\n\n  space(force = false) {\n    if (this.format.compact) return;\n\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n\n      if (lastCp !== 32 && lastCp !== 10) {\n        this._space();\n      }\n    }\n  }\n\n  word(str) {\n    if (this._endsWithWord || this.endsWith(47) && str.charCodeAt(0) === 47) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n\n    this._endsWithWord = true;\n  }\n\n  number(str) {\n    this.word(str);\n    this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;\n  }\n\n  token(str) {\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n\n    if (str === \"--\" && lastChar === 33 || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n  }\n\n  newline(i = 1) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    const charBeforeNewline = this.endsWithCharAndNewline();\n    if (charBeforeNewline === 10) return;\n\n    if (charBeforeNewline === 123 || charBeforeNewline === 58) {\n      i--;\n    }\n\n    if (i <= 0) return;\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n  }\n\n  endsWith(char) {\n    return this.getLastChar() === char;\n  }\n\n  getLastChar() {\n    return this._buf.getLastChar();\n  }\n\n  endsWithCharAndNewline() {\n    return this._buf.endsWithCharAndNewline();\n  }\n\n  removeTrailingNewline() {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc, cb) {\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop, loc) {\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  withSource(prop, loc, cb) {\n    this._catchUp(prop, loc);\n\n    this._buf.withSource(prop, loc, cb);\n  }\n\n  _space() {\n    this._append(\" \", true);\n  }\n\n  _newline() {\n    this._append(\"\\n\", true);\n  }\n\n  _append(str, queue = false) {\n    this._maybeAddParen(str);\n\n    this._maybeIndent(str);\n\n    if (queue) this._buf.queue(str);else this._buf.append(str);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(str) {\n    if (this._indent && this.endsWith(10) && str.charCodeAt(0) !== 10) {\n      this._buf.queue(this._getIndent());\n    }\n  }\n\n  _maybeAddParen(str) {\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n    let i;\n\n    for (i = 0; i < str.length && str[i] === \" \"; i++) continue;\n\n    if (i === str.length) {\n      return;\n    }\n\n    const cha = str[i];\n\n    if (cha !== \"\\n\") {\n      if (cha !== \"/\" || i + 1 === str.length) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n\n      const chaPost = str[i + 1];\n\n      if (chaPost === \"*\") {\n        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) {\n          return;\n        }\n      } else if (chaPost !== \"/\") {\n        this._parenPushNewlineState = null;\n        return;\n      }\n    }\n\n    this.token(\"(\");\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  _catchUp(prop, loc) {\n    if (!this.format.retainLines) return;\n    const pos = loc ? loc[prop] : null;\n\n    if ((pos == null ? void 0 : pos.line) != null) {\n      const count = pos.line - this._buf.getCurrentLine();\n\n      for (let i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }\n\n  _getIndent() {\n    return this.format.indent.style.repeat(this._indent);\n  }\n\n  startTerminatorless(isLabel = false) {\n    if (isLabel) {\n      this._noLineTerminator = true;\n      return null;\n    } else {\n      return this._parenPushNewlineState = {\n        printed: false\n      };\n    }\n  }\n\n  endTerminatorless(state) {\n    this._noLineTerminator = false;\n\n    if (state != null && state.printed) {\n      this.dedent();\n      this.newline();\n      this.token(\")\");\n    }\n  }\n\n  print(node, parent) {\n    if (!node) return;\n    const oldConcise = this.format.concise;\n\n    if (node._compact) {\n      this.format.concise = true;\n    }\n\n    const printMethod = this[node.type];\n\n    if (!printMethod) {\n      throw new ReferenceError(`unknown node of type ${JSON.stringify(node.type)} with constructor ${JSON.stringify(node == null ? void 0 : node.constructor.name)}`);\n    }\n\n    this._printStack.push(node);\n\n    const oldInAux = this._insideAux;\n    this._insideAux = !node.loc;\n\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    let shouldPrintParens = needsParens(node, parent, this._printStack);\n\n    if (this.format.retainFunctionParens && node.type === \"FunctionExpression\" && node.extra && node.extra.parenthesized) {\n      shouldPrintParens = true;\n    }\n\n    if (shouldPrintParens) this.token(\"(\");\n\n    this._printLeadingComments(node);\n\n    const loc = isProgram(node) || isFile(node) ? null : node.loc;\n    this.withSource(\"start\", loc, () => {\n      printMethod.call(this, node, parent);\n    });\n\n    this._printTrailingComments(node);\n\n    if (shouldPrintParens) this.token(\")\");\n\n    this._printStack.pop();\n\n    this.format.concise = oldConcise;\n    this._insideAux = oldInAux;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n    const comment = this.format.auxiliaryCommentBefore;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n    const comment = this.format.auxiliaryCommentAfter;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  getPossibleRaw(node) {\n    const extra = node.extra;\n\n    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {\n      return extra.raw;\n    }\n  }\n\n  printJoin(nodes, parent, opts = {}) {\n    if (!(nodes != null && nodes.length)) return;\n    if (opts.indent) this.indent();\n    const newlineOpts = {\n      addNewlines: opts.addNewlines\n    };\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);\n      this.print(node, parent);\n\n      if (opts.iterator) {\n        opts.iterator(node, i);\n      }\n\n      if (opts.separator && i < nodes.length - 1) {\n        opts.separator.call(this);\n      }\n\n      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);\n    }\n\n    if (opts.indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node, parent) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent) {\n    const node = parent.body;\n\n    if (!isEmptyStatement(node)) {\n      this.space();\n    }\n\n    this.print(node, parent);\n  }\n\n  _printTrailingComments(node) {\n    this._printComments(this._getComments(false, node));\n  }\n\n  _printLeadingComments(node) {\n    this._printComments(this._getComments(true, node), true);\n  }\n\n  printInnerComments(node, indent = true) {\n    var _node$innerComments;\n\n    if (!((_node$innerComments = node.innerComments) != null && _node$innerComments.length)) return;\n    if (indent) this.indent();\n\n    this._printComments(node.innerComments);\n\n    if (indent) this.dedent();\n  }\n\n  printSequence(nodes, parent, opts = {}) {\n    opts.statement = true;\n    return this.printJoin(nodes, parent, opts);\n  }\n\n  printList(items, parent, opts = {}) {\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n\n    return this.printJoin(items, parent, opts);\n  }\n\n  _printNewline(leading, node, parent, opts) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    let lines = 0;\n\n    if (this._buf.hasContent()) {\n      if (!leading) lines++;\n      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n      const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;\n      if (needs(node, parent)) lines++;\n    }\n\n    this.newline(Math.min(2, lines));\n  }\n\n  _getComments(leading, node) {\n    return node && (leading ? node.leadingComments : node.trailingComments) || [];\n  }\n\n  _printComment(comment, skipNewLines) {\n    if (!this.format.shouldPrintComment(comment.value)) return;\n    if (comment.ignore) return;\n    if (this._printedComments.has(comment)) return;\n\n    this._printedComments.add(comment);\n\n    const isBlockComment = comment.type === \"CommentBlock\";\n    const printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;\n    if (printNewLines && this._buf.hasContent()) this.newline(1);\n    const lastCharCode = this.getLastChar();\n\n    if (lastCharCode !== 91 && lastCharCode !== 123) {\n      this.space();\n    }\n\n    let val = !isBlockComment && !this._noLineTerminator ? `//${comment.value}\\n` : `/*${comment.value}*/`;\n\n    if (isBlockComment && this.format.indent.adjustMultilineComment) {\n      var _comment$loc;\n\n      const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;\n\n      if (offset) {\n        const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n        val = val.replace(newlineRegex, \"\\n\");\n      }\n\n      const indentSize = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn());\n      val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n    }\n\n    if (this.endsWith(47)) this._space();\n    this.withSource(\"start\", comment.loc, () => {\n      this._append(val);\n    });\n    if (printNewLines) this.newline(1);\n  }\n\n  _printComments(comments, inlinePureAnnotation) {\n    if (!(comments != null && comments.length)) return;\n\n    if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {\n      this._printComment(comments[0], this._buf.hasContent() && !this.endsWith(10));\n    } else {\n      for (const comment of comments) {\n        this._printComment(comment);\n      }\n    }\n  }\n\n  printAssertions(node) {\n    var _node$assertions;\n\n    if ((_node$assertions = node.assertions) != null && _node$assertions.length) {\n      this.space();\n      this.word(\"assert\");\n      this.space();\n      this.token(\"{\");\n      this.space();\n      this.printList(node.assertions, node);\n      this.space();\n      this.token(\"}\");\n    }\n  }\n\n}\n\nObject.assign(Printer.prototype, generatorFunctions);\n{\n  Printer.prototype.Noop = function Noop() {};\n}\nvar _default = Printer;\nexports.default = _default;\n\nfunction commaSeparator() {\n  this.token(\",\");\n  this.space();\n}","map":{"version":3,"sources":["/Users/alperenalkan/obss/frontend/frontend/node_modules/@babel/generator/lib/printer.js"],"names":["Object","defineProperty","exports","value","default","_buffer","require","n","t","generatorFunctions","SCIENTIFIC_NOTATION","ZERO_DECIMAL_INTEGER","NON_DECIMAL_LITERAL","PURE_ANNOTATION_RE","isProgram","isFile","isEmptyStatement","needsParens","needsWhitespaceAfter","needsWhitespaceBefore","Printer","constructor","format","map","inForStatementInitCounter","_printStack","_indent","_insideAux","_parenPushNewlineState","_noLineTerminator","_printAuxAfterOnNextUserNode","_printedComments","WeakSet","_endsWithInteger","_endsWithWord","_buf","generate","ast","print","_maybeAddAuxComment","get","indent","compact","concise","dedent","semicolon","force","_append","rightBrace","minified","removeLastSemicolon","token","space","_space","hasContent","lastCp","getLastChar","word","str","endsWith","charCodeAt","number","Number","isInteger","test","length","lastChar","strFirst","newline","i","retainLines","charBeforeNewline","endsWithCharAndNewline","j","_newline","char","removeTrailingNewline","exactSource","loc","cb","_catchUp","source","prop","withSource","queue","_maybeAddParen","_maybeIndent","append","_getIndent","parenPushNewlineState","cha","chaPost","slice","printed","pos","line","count","getCurrentLine","style","repeat","startTerminatorless","isLabel","endTerminatorless","state","node","parent","oldConcise","_compact","printMethod","type","ReferenceError","JSON","stringify","name","push","oldInAux","shouldPrintParens","retainFunctionParens","extra","parenthesized","_printLeadingComments","call","_printTrailingComments","pop","enteredPositionlessNode","_printAuxBeforeComment","_printAuxAfterComment","comment","auxiliaryCommentBefore","_printComment","auxiliaryCommentAfter","getPossibleRaw","raw","rawValue","printJoin","nodes","opts","newlineOpts","addNewlines","statement","_printNewline","iterator","separator","printAndIndentOnComments","leadingComments","printBlock","body","_printComments","_getComments","printInnerComments","_node$innerComments","innerComments","printSequence","printList","items","commaSeparator","leading","lines","needs","Math","min","trailingComments","skipNewLines","shouldPrintComment","ignore","has","add","isBlockComment","printNewLines","lastCharCode","val","adjustMultilineComment","_comment$loc","offset","start","column","newlineRegex","RegExp","replace","indentSize","max","getCurrentColumn","comments","inlinePureAnnotation","printAssertions","_node$assertions","assertions","assign","prototype","Noop","_default"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,OAAO,GAAGC,OAAO,CAAC,UAAD,CAArB;;AAEA,IAAIC,CAAC,GAAGD,OAAO,CAAC,QAAD,CAAf;;AAEA,IAAIE,CAAC,GAAGF,OAAO,CAAC,cAAD,CAAf;;AAEA,IAAIG,kBAAkB,GAAGH,OAAO,CAAC,cAAD,CAAhC;;AAEA,MAAMI,mBAAmB,GAAG,IAA5B;AACA,MAAMC,oBAAoB,GAAG,OAA7B;AACA,MAAMC,mBAAmB,GAAG,SAA5B;AACA,MAAMC,kBAAkB,GAAG,sBAA3B;AACA,MAAM;AACJC,EAAAA,SADI;AAEJC,EAAAA,MAFI;AAGJC,EAAAA;AAHI,IAIFR,CAJJ;AAKA,MAAM;AACJS,EAAAA,WADI;AAEJC,EAAAA,oBAFI;AAGJC,EAAAA;AAHI,IAIFZ,CAJJ;;AAMA,MAAMa,OAAN,CAAc;AACZC,EAAAA,WAAW,CAACC,MAAD,EAASC,GAAT,EAAc;AACvB,SAAKC,yBAAL,GAAiC,CAAjC;AACA,SAAKC,WAAL,GAAmB,EAAnB;AACA,SAAKC,OAAL,GAAe,CAAf;AACA,SAAKC,UAAL,GAAkB,KAAlB;AACA,SAAKC,sBAAL,GAA8B,IAA9B;AACA,SAAKC,iBAAL,GAAyB,KAAzB;AACA,SAAKC,4BAAL,GAAoC,KAApC;AACA,SAAKC,gBAAL,GAAwB,IAAIC,OAAJ,EAAxB;AACA,SAAKC,gBAAL,GAAwB,KAAxB;AACA,SAAKC,aAAL,GAAqB,KAArB;AACA,SAAKZ,MAAL,GAAcA,MAAd;AACA,SAAKa,IAAL,GAAY,IAAI9B,OAAO,CAACD,OAAZ,CAAoBmB,GAApB,CAAZ;AACD;;AAEDa,EAAAA,QAAQ,CAACC,GAAD,EAAM;AACZ,SAAKC,KAAL,CAAWD,GAAX;;AAEA,SAAKE,mBAAL;;AAEA,WAAO,KAAKJ,IAAL,CAAUK,GAAV,EAAP;AACD;;AAEDC,EAAAA,MAAM,GAAG;AACP,QAAI,KAAKnB,MAAL,CAAYoB,OAAZ,IAAuB,KAAKpB,MAAL,CAAYqB,OAAvC,EAAgD;AAChD,SAAKjB,OAAL;AACD;;AAEDkB,EAAAA,MAAM,GAAG;AACP,QAAI,KAAKtB,MAAL,CAAYoB,OAAZ,IAAuB,KAAKpB,MAAL,CAAYqB,OAAvC,EAAgD;AAChD,SAAKjB,OAAL;AACD;;AAEDmB,EAAAA,SAAS,CAACC,KAAK,GAAG,KAAT,EAAgB;AACvB,SAAKP,mBAAL;;AAEA,SAAKQ,OAAL,CAAa,GAAb,EAAkB,CAACD,KAAnB;AACD;;AAEDE,EAAAA,UAAU,GAAG;AACX,QAAI,KAAK1B,MAAL,CAAY2B,QAAhB,EAA0B;AACxB,WAAKd,IAAL,CAAUe,mBAAV;AACD;;AAED,SAAKC,KAAL,CAAW,GAAX;AACD;;AAEDC,EAAAA,KAAK,CAACN,KAAK,GAAG,KAAT,EAAgB;AACnB,QAAI,KAAKxB,MAAL,CAAYoB,OAAhB,EAAyB;;AAEzB,QAAII,KAAJ,EAAW;AACT,WAAKO,MAAL;AACD,KAFD,MAEO,IAAI,KAAKlB,IAAL,CAAUmB,UAAV,EAAJ,EAA4B;AACjC,YAAMC,MAAM,GAAG,KAAKC,WAAL,EAAf;;AAEA,UAAID,MAAM,KAAK,EAAX,IAAiBA,MAAM,KAAK,EAAhC,EAAoC;AAClC,aAAKF,MAAL;AACD;AACF;AACF;;AAEDI,EAAAA,IAAI,CAACC,GAAD,EAAM;AACR,QAAI,KAAKxB,aAAL,IAAsB,KAAKyB,QAAL,CAAc,EAAd,KAAqBD,GAAG,CAACE,UAAJ,CAAe,CAAf,MAAsB,EAArE,EAAyE;AACvE,WAAKP,MAAL;AACD;;AAED,SAAKd,mBAAL;;AAEA,SAAKQ,OAAL,CAAaW,GAAb;;AAEA,SAAKxB,aAAL,GAAqB,IAArB;AACD;;AAED2B,EAAAA,MAAM,CAACH,GAAD,EAAM;AACV,SAAKD,IAAL,CAAUC,GAAV;AACA,SAAKzB,gBAAL,GAAwB6B,MAAM,CAACC,SAAP,CAAiB,CAACL,GAAlB,KAA0B,CAAC9C,mBAAmB,CAACoD,IAApB,CAAyBN,GAAzB,CAA3B,IAA4D,CAAChD,mBAAmB,CAACsD,IAApB,CAAyBN,GAAzB,CAA7D,IAA8F,CAAC/C,oBAAoB,CAACqD,IAArB,CAA0BN,GAA1B,CAA/F,IAAiIA,GAAG,CAACE,UAAJ,CAAeF,GAAG,CAACO,MAAJ,GAAa,CAA5B,MAAmC,EAA5L;AACD;;AAEDd,EAAAA,KAAK,CAACO,GAAD,EAAM;AACT,UAAMQ,QAAQ,GAAG,KAAKV,WAAL,EAAjB;AACA,UAAMW,QAAQ,GAAGT,GAAG,CAACE,UAAJ,CAAe,CAAf,CAAjB;;AAEA,QAAIF,GAAG,KAAK,IAAR,IAAgBQ,QAAQ,KAAK,EAA7B,IAAmCC,QAAQ,KAAK,EAAb,IAAmBD,QAAQ,KAAK,EAAnE,IAAyEC,QAAQ,KAAK,EAAb,IAAmBD,QAAQ,KAAK,EAAzG,IAA+GC,QAAQ,KAAK,EAAb,IAAmB,KAAKlC,gBAA3I,EAA6J;AAC3J,WAAKoB,MAAL;AACD;;AAED,SAAKd,mBAAL;;AAEA,SAAKQ,OAAL,CAAaW,GAAb;AACD;;AAEDU,EAAAA,OAAO,CAACC,CAAC,GAAG,CAAL,EAAQ;AACb,QAAI,KAAK/C,MAAL,CAAYgD,WAAZ,IAA2B,KAAKhD,MAAL,CAAYoB,OAA3C,EAAoD;;AAEpD,QAAI,KAAKpB,MAAL,CAAYqB,OAAhB,EAAyB;AACvB,WAAKS,KAAL;AACA;AACD;;AAED,UAAMmB,iBAAiB,GAAG,KAAKC,sBAAL,EAA1B;AACA,QAAID,iBAAiB,KAAK,EAA1B,EAA8B;;AAE9B,QAAIA,iBAAiB,KAAK,GAAtB,IAA6BA,iBAAiB,KAAK,EAAvD,EAA2D;AACzDF,MAAAA,CAAC;AACF;;AAED,QAAIA,CAAC,IAAI,CAAT,EAAY;;AAEZ,SAAK,IAAII,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,CAApB,EAAuBI,CAAC,EAAxB,EAA4B;AAC1B,WAAKC,QAAL;AACD;AACF;;AAEDf,EAAAA,QAAQ,CAACgB,IAAD,EAAO;AACb,WAAO,KAAKnB,WAAL,OAAuBmB,IAA9B;AACD;;AAEDnB,EAAAA,WAAW,GAAG;AACZ,WAAO,KAAKrB,IAAL,CAAUqB,WAAV,EAAP;AACD;;AAEDgB,EAAAA,sBAAsB,GAAG;AACvB,WAAO,KAAKrC,IAAL,CAAUqC,sBAAV,EAAP;AACD;;AAEDI,EAAAA,qBAAqB,GAAG;AACtB,SAAKzC,IAAL,CAAUyC,qBAAV;AACD;;AAEDC,EAAAA,WAAW,CAACC,GAAD,EAAMC,EAAN,EAAU;AACnB,SAAKC,QAAL,CAAc,OAAd,EAAuBF,GAAvB;;AAEA,SAAK3C,IAAL,CAAU0C,WAAV,CAAsBC,GAAtB,EAA2BC,EAA3B;AACD;;AAEDE,EAAAA,MAAM,CAACC,IAAD,EAAOJ,GAAP,EAAY;AAChB,SAAKE,QAAL,CAAcE,IAAd,EAAoBJ,GAApB;;AAEA,SAAK3C,IAAL,CAAU8C,MAAV,CAAiBC,IAAjB,EAAuBJ,GAAvB;AACD;;AAEDK,EAAAA,UAAU,CAACD,IAAD,EAAOJ,GAAP,EAAYC,EAAZ,EAAgB;AACxB,SAAKC,QAAL,CAAcE,IAAd,EAAoBJ,GAApB;;AAEA,SAAK3C,IAAL,CAAUgD,UAAV,CAAqBD,IAArB,EAA2BJ,GAA3B,EAAgCC,EAAhC;AACD;;AAED1B,EAAAA,MAAM,GAAG;AACP,SAAKN,OAAL,CAAa,GAAb,EAAkB,IAAlB;AACD;;AAED2B,EAAAA,QAAQ,GAAG;AACT,SAAK3B,OAAL,CAAa,IAAb,EAAmB,IAAnB;AACD;;AAEDA,EAAAA,OAAO,CAACW,GAAD,EAAM0B,KAAK,GAAG,KAAd,EAAqB;AAC1B,SAAKC,cAAL,CAAoB3B,GAApB;;AAEA,SAAK4B,YAAL,CAAkB5B,GAAlB;;AAEA,QAAI0B,KAAJ,EAAW,KAAKjD,IAAL,CAAUiD,KAAV,CAAgB1B,GAAhB,EAAX,KAAqC,KAAKvB,IAAL,CAAUoD,MAAV,CAAiB7B,GAAjB;AACrC,SAAKxB,aAAL,GAAqB,KAArB;AACA,SAAKD,gBAAL,GAAwB,KAAxB;AACD;;AAEDqD,EAAAA,YAAY,CAAC5B,GAAD,EAAM;AAChB,QAAI,KAAKhC,OAAL,IAAgB,KAAKiC,QAAL,CAAc,EAAd,CAAhB,IAAqCD,GAAG,CAACE,UAAJ,CAAe,CAAf,MAAsB,EAA/D,EAAmE;AACjE,WAAKzB,IAAL,CAAUiD,KAAV,CAAgB,KAAKI,UAAL,EAAhB;AACD;AACF;;AAEDH,EAAAA,cAAc,CAAC3B,GAAD,EAAM;AAClB,UAAM+B,qBAAqB,GAAG,KAAK7D,sBAAnC;AACA,QAAI,CAAC6D,qBAAL,EAA4B;AAC5B,QAAIpB,CAAJ;;AAEA,SAAKA,CAAC,GAAG,CAAT,EAAYA,CAAC,GAAGX,GAAG,CAACO,MAAR,IAAkBP,GAAG,CAACW,CAAD,CAAH,KAAW,GAAzC,EAA8CA,CAAC,EAA/C,EAAmD;;AAEnD,QAAIA,CAAC,KAAKX,GAAG,CAACO,MAAd,EAAsB;AACpB;AACD;;AAED,UAAMyB,GAAG,GAAGhC,GAAG,CAACW,CAAD,CAAf;;AAEA,QAAIqB,GAAG,KAAK,IAAZ,EAAkB;AAChB,UAAIA,GAAG,KAAK,GAAR,IAAerB,CAAC,GAAG,CAAJ,KAAUX,GAAG,CAACO,MAAjC,EAAyC;AACvC,aAAKrC,sBAAL,GAA8B,IAA9B;AACA;AACD;;AAED,YAAM+D,OAAO,GAAGjC,GAAG,CAACW,CAAC,GAAG,CAAL,CAAnB;;AAEA,UAAIsB,OAAO,KAAK,GAAhB,EAAqB;AACnB,YAAI9E,kBAAkB,CAACmD,IAAnB,CAAwBN,GAAG,CAACkC,KAAJ,CAAUvB,CAAC,GAAG,CAAd,EAAiBX,GAAG,CAACO,MAAJ,GAAa,CAA9B,CAAxB,CAAJ,EAA+D;AAC7D;AACD;AACF,OAJD,MAIO,IAAI0B,OAAO,KAAK,GAAhB,EAAqB;AAC1B,aAAK/D,sBAAL,GAA8B,IAA9B;AACA;AACD;AACF;;AAED,SAAKuB,KAAL,CAAW,GAAX;AACA,SAAKV,MAAL;AACAgD,IAAAA,qBAAqB,CAACI,OAAtB,GAAgC,IAAhC;AACD;;AAEDb,EAAAA,QAAQ,CAACE,IAAD,EAAOJ,GAAP,EAAY;AAClB,QAAI,CAAC,KAAKxD,MAAL,CAAYgD,WAAjB,EAA8B;AAC9B,UAAMwB,GAAG,GAAGhB,GAAG,GAAGA,GAAG,CAACI,IAAD,CAAN,GAAe,IAA9B;;AAEA,QAAI,CAACY,GAAG,IAAI,IAAP,GAAc,KAAK,CAAnB,GAAuBA,GAAG,CAACC,IAA5B,KAAqC,IAAzC,EAA+C;AAC7C,YAAMC,KAAK,GAAGF,GAAG,CAACC,IAAJ,GAAW,KAAK5D,IAAL,CAAU8D,cAAV,EAAzB;;AAEA,WAAK,IAAI5B,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2B,KAApB,EAA2B3B,CAAC,EAA5B,EAAgC;AAC9B,aAAKK,QAAL;AACD;AACF;AACF;;AAEDc,EAAAA,UAAU,GAAG;AACX,WAAO,KAAKlE,MAAL,CAAYmB,MAAZ,CAAmByD,KAAnB,CAAyBC,MAAzB,CAAgC,KAAKzE,OAArC,CAAP;AACD;;AAED0E,EAAAA,mBAAmB,CAACC,OAAO,GAAG,KAAX,EAAkB;AACnC,QAAIA,OAAJ,EAAa;AACX,WAAKxE,iBAAL,GAAyB,IAAzB;AACA,aAAO,IAAP;AACD,KAHD,MAGO;AACL,aAAO,KAAKD,sBAAL,GAA8B;AACnCiE,QAAAA,OAAO,EAAE;AAD0B,OAArC;AAGD;AACF;;AAEDS,EAAAA,iBAAiB,CAACC,KAAD,EAAQ;AACvB,SAAK1E,iBAAL,GAAyB,KAAzB;;AAEA,QAAI0E,KAAK,IAAI,IAAT,IAAiBA,KAAK,CAACV,OAA3B,EAAoC;AAClC,WAAKjD,MAAL;AACA,WAAKwB,OAAL;AACA,WAAKjB,KAAL,CAAW,GAAX;AACD;AACF;;AAEDb,EAAAA,KAAK,CAACkE,IAAD,EAAOC,MAAP,EAAe;AAClB,QAAI,CAACD,IAAL,EAAW;AACX,UAAME,UAAU,GAAG,KAAKpF,MAAL,CAAYqB,OAA/B;;AAEA,QAAI6D,IAAI,CAACG,QAAT,EAAmB;AACjB,WAAKrF,MAAL,CAAYqB,OAAZ,GAAsB,IAAtB;AACD;;AAED,UAAMiE,WAAW,GAAG,KAAKJ,IAAI,CAACK,IAAV,CAApB;;AAEA,QAAI,CAACD,WAAL,EAAkB;AAChB,YAAM,IAAIE,cAAJ,CAAoB,wBAAuBC,IAAI,CAACC,SAAL,CAAeR,IAAI,CAACK,IAApB,CAA0B,qBAAoBE,IAAI,CAACC,SAAL,CAAeR,IAAI,IAAI,IAAR,GAAe,KAAK,CAApB,GAAwBA,IAAI,CAACnF,WAAL,CAAiB4F,IAAxD,CAA8D,EAAvJ,CAAN;AACD;;AAED,SAAKxF,WAAL,CAAiByF,IAAjB,CAAsBV,IAAtB;;AAEA,UAAMW,QAAQ,GAAG,KAAKxF,UAAtB;AACA,SAAKA,UAAL,GAAkB,CAAC6E,IAAI,CAAC1B,GAAxB;;AAEA,SAAKvC,mBAAL,CAAyB,KAAKZ,UAAL,IAAmB,CAACwF,QAA7C;;AAEA,QAAIC,iBAAiB,GAAGnG,WAAW,CAACuF,IAAD,EAAOC,MAAP,EAAe,KAAKhF,WAApB,CAAnC;;AAEA,QAAI,KAAKH,MAAL,CAAY+F,oBAAZ,IAAoCb,IAAI,CAACK,IAAL,KAAc,oBAAlD,IAA0EL,IAAI,CAACc,KAA/E,IAAwFd,IAAI,CAACc,KAAL,CAAWC,aAAvG,EAAsH;AACpHH,MAAAA,iBAAiB,GAAG,IAApB;AACD;;AAED,QAAIA,iBAAJ,EAAuB,KAAKjE,KAAL,CAAW,GAAX;;AAEvB,SAAKqE,qBAAL,CAA2BhB,IAA3B;;AAEA,UAAM1B,GAAG,GAAGhE,SAAS,CAAC0F,IAAD,CAAT,IAAmBzF,MAAM,CAACyF,IAAD,CAAzB,GAAkC,IAAlC,GAAyCA,IAAI,CAAC1B,GAA1D;AACA,SAAKK,UAAL,CAAgB,OAAhB,EAAyBL,GAAzB,EAA8B,MAAM;AAClC8B,MAAAA,WAAW,CAACa,IAAZ,CAAiB,IAAjB,EAAuBjB,IAAvB,EAA6BC,MAA7B;AACD,KAFD;;AAIA,SAAKiB,sBAAL,CAA4BlB,IAA5B;;AAEA,QAAIY,iBAAJ,EAAuB,KAAKjE,KAAL,CAAW,GAAX;;AAEvB,SAAK1B,WAAL,CAAiBkG,GAAjB;;AAEA,SAAKrG,MAAL,CAAYqB,OAAZ,GAAsB+D,UAAtB;AACA,SAAK/E,UAAL,GAAkBwF,QAAlB;AACD;;AAED5E,EAAAA,mBAAmB,CAACqF,uBAAD,EAA0B;AAC3C,QAAIA,uBAAJ,EAA6B,KAAKC,sBAAL;AAC7B,QAAI,CAAC,KAAKlG,UAAV,EAAsB,KAAKmG,qBAAL;AACvB;;AAEDD,EAAAA,sBAAsB,GAAG;AACvB,QAAI,KAAK/F,4BAAT,EAAuC;AACvC,SAAKA,4BAAL,GAAoC,IAApC;AACA,UAAMiG,OAAO,GAAG,KAAKzG,MAAL,CAAY0G,sBAA5B;;AAEA,QAAID,OAAJ,EAAa;AACX,WAAKE,aAAL,CAAmB;AACjBpB,QAAAA,IAAI,EAAE,cADW;AAEjB1G,QAAAA,KAAK,EAAE4H;AAFU,OAAnB;AAID;AACF;;AAEDD,EAAAA,qBAAqB,GAAG;AACtB,QAAI,CAAC,KAAKhG,4BAAV,EAAwC;AACxC,SAAKA,4BAAL,GAAoC,KAApC;AACA,UAAMiG,OAAO,GAAG,KAAKzG,MAAL,CAAY4G,qBAA5B;;AAEA,QAAIH,OAAJ,EAAa;AACX,WAAKE,aAAL,CAAmB;AACjBpB,QAAAA,IAAI,EAAE,cADW;AAEjB1G,QAAAA,KAAK,EAAE4H;AAFU,OAAnB;AAID;AACF;;AAEDI,EAAAA,cAAc,CAAC3B,IAAD,EAAO;AACnB,UAAMc,KAAK,GAAGd,IAAI,CAACc,KAAnB;;AAEA,QAAIA,KAAK,IAAIA,KAAK,CAACc,GAAN,IAAa,IAAtB,IAA8Bd,KAAK,CAACe,QAAN,IAAkB,IAAhD,IAAwD7B,IAAI,CAACrG,KAAL,KAAemH,KAAK,CAACe,QAAjF,EAA2F;AACzF,aAAOf,KAAK,CAACc,GAAb;AACD;AACF;;AAEDE,EAAAA,SAAS,CAACC,KAAD,EAAQ9B,MAAR,EAAgB+B,IAAI,GAAG,EAAvB,EAA2B;AAClC,QAAI,EAAED,KAAK,IAAI,IAAT,IAAiBA,KAAK,CAACtE,MAAzB,CAAJ,EAAsC;AACtC,QAAIuE,IAAI,CAAC/F,MAAT,EAAiB,KAAKA,MAAL;AACjB,UAAMgG,WAAW,GAAG;AAClBC,MAAAA,WAAW,EAAEF,IAAI,CAACE;AADA,KAApB;;AAIA,SAAK,IAAIrE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkE,KAAK,CAACtE,MAA1B,EAAkCI,CAAC,EAAnC,EAAuC;AACrC,YAAMmC,IAAI,GAAG+B,KAAK,CAAClE,CAAD,CAAlB;AACA,UAAI,CAACmC,IAAL,EAAW;AACX,UAAIgC,IAAI,CAACG,SAAT,EAAoB,KAAKC,aAAL,CAAmB,IAAnB,EAAyBpC,IAAzB,EAA+BC,MAA/B,EAAuCgC,WAAvC;AACpB,WAAKnG,KAAL,CAAWkE,IAAX,EAAiBC,MAAjB;;AAEA,UAAI+B,IAAI,CAACK,QAAT,EAAmB;AACjBL,QAAAA,IAAI,CAACK,QAAL,CAAcrC,IAAd,EAAoBnC,CAApB;AACD;;AAED,UAAImE,IAAI,CAACM,SAAL,IAAkBzE,CAAC,GAAGkE,KAAK,CAACtE,MAAN,GAAe,CAAzC,EAA4C;AAC1CuE,QAAAA,IAAI,CAACM,SAAL,CAAerB,IAAf,CAAoB,IAApB;AACD;;AAED,UAAIe,IAAI,CAACG,SAAT,EAAoB,KAAKC,aAAL,CAAmB,KAAnB,EAA0BpC,IAA1B,EAAgCC,MAAhC,EAAwCgC,WAAxC;AACrB;;AAED,QAAID,IAAI,CAAC/F,MAAT,EAAiB,KAAKG,MAAL;AAClB;;AAEDmG,EAAAA,wBAAwB,CAACvC,IAAD,EAAOC,MAAP,EAAe;AACrC,UAAMhE,MAAM,GAAG+D,IAAI,CAACwC,eAAL,IAAwBxC,IAAI,CAACwC,eAAL,CAAqB/E,MAArB,GAA8B,CAArE;AACA,QAAIxB,MAAJ,EAAY,KAAKA,MAAL;AACZ,SAAKH,KAAL,CAAWkE,IAAX,EAAiBC,MAAjB;AACA,QAAIhE,MAAJ,EAAY,KAAKG,MAAL;AACb;;AAEDqG,EAAAA,UAAU,CAACxC,MAAD,EAAS;AACjB,UAAMD,IAAI,GAAGC,MAAM,CAACyC,IAApB;;AAEA,QAAI,CAAClI,gBAAgB,CAACwF,IAAD,CAArB,EAA6B;AAC3B,WAAKpD,KAAL;AACD;;AAED,SAAKd,KAAL,CAAWkE,IAAX,EAAiBC,MAAjB;AACD;;AAEDiB,EAAAA,sBAAsB,CAAClB,IAAD,EAAO;AAC3B,SAAK2C,cAAL,CAAoB,KAAKC,YAAL,CAAkB,KAAlB,EAAyB5C,IAAzB,CAApB;AACD;;AAEDgB,EAAAA,qBAAqB,CAAChB,IAAD,EAAO;AAC1B,SAAK2C,cAAL,CAAoB,KAAKC,YAAL,CAAkB,IAAlB,EAAwB5C,IAAxB,CAApB,EAAmD,IAAnD;AACD;;AAED6C,EAAAA,kBAAkB,CAAC7C,IAAD,EAAO/D,MAAM,GAAG,IAAhB,EAAsB;AACtC,QAAI6G,mBAAJ;;AAEA,QAAI,EAAE,CAACA,mBAAmB,GAAG9C,IAAI,CAAC+C,aAA5B,KAA8C,IAA9C,IAAsDD,mBAAmB,CAACrF,MAA5E,CAAJ,EAAyF;AACzF,QAAIxB,MAAJ,EAAY,KAAKA,MAAL;;AAEZ,SAAK0G,cAAL,CAAoB3C,IAAI,CAAC+C,aAAzB;;AAEA,QAAI9G,MAAJ,EAAY,KAAKG,MAAL;AACb;;AAED4G,EAAAA,aAAa,CAACjB,KAAD,EAAQ9B,MAAR,EAAgB+B,IAAI,GAAG,EAAvB,EAA2B;AACtCA,IAAAA,IAAI,CAACG,SAAL,GAAiB,IAAjB;AACA,WAAO,KAAKL,SAAL,CAAeC,KAAf,EAAsB9B,MAAtB,EAA8B+B,IAA9B,CAAP;AACD;;AAEDiB,EAAAA,SAAS,CAACC,KAAD,EAAQjD,MAAR,EAAgB+B,IAAI,GAAG,EAAvB,EAA2B;AAClC,QAAIA,IAAI,CAACM,SAAL,IAAkB,IAAtB,EAA4B;AAC1BN,MAAAA,IAAI,CAACM,SAAL,GAAiBa,cAAjB;AACD;;AAED,WAAO,KAAKrB,SAAL,CAAeoB,KAAf,EAAsBjD,MAAtB,EAA8B+B,IAA9B,CAAP;AACD;;AAEDI,EAAAA,aAAa,CAACgB,OAAD,EAAUpD,IAAV,EAAgBC,MAAhB,EAAwB+B,IAAxB,EAA8B;AACzC,QAAI,KAAKlH,MAAL,CAAYgD,WAAZ,IAA2B,KAAKhD,MAAL,CAAYoB,OAA3C,EAAoD;;AAEpD,QAAI,KAAKpB,MAAL,CAAYqB,OAAhB,EAAyB;AACvB,WAAKS,KAAL;AACA;AACD;;AAED,QAAIyG,KAAK,GAAG,CAAZ;;AAEA,QAAI,KAAK1H,IAAL,CAAUmB,UAAV,EAAJ,EAA4B;AAC1B,UAAI,CAACsG,OAAL,EAAcC,KAAK;AACnB,UAAIrB,IAAI,CAACE,WAAT,EAAsBmB,KAAK,IAAIrB,IAAI,CAACE,WAAL,CAAiBkB,OAAjB,EAA0BpD,IAA1B,KAAmC,CAA5C;AACtB,YAAMsD,KAAK,GAAGF,OAAO,GAAGzI,qBAAH,GAA2BD,oBAAhD;AACA,UAAI4I,KAAK,CAACtD,IAAD,EAAOC,MAAP,CAAT,EAAyBoD,KAAK;AAC/B;;AAED,SAAKzF,OAAL,CAAa2F,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYH,KAAZ,CAAb;AACD;;AAEDT,EAAAA,YAAY,CAACQ,OAAD,EAAUpD,IAAV,EAAgB;AAC1B,WAAOA,IAAI,KAAKoD,OAAO,GAAGpD,IAAI,CAACwC,eAAR,GAA0BxC,IAAI,CAACyD,gBAA3C,CAAJ,IAAoE,EAA3E;AACD;;AAEDhC,EAAAA,aAAa,CAACF,OAAD,EAAUmC,YAAV,EAAwB;AACnC,QAAI,CAAC,KAAK5I,MAAL,CAAY6I,kBAAZ,CAA+BpC,OAAO,CAAC5H,KAAvC,CAAL,EAAoD;AACpD,QAAI4H,OAAO,CAACqC,MAAZ,EAAoB;AACpB,QAAI,KAAKrI,gBAAL,CAAsBsI,GAAtB,CAA0BtC,OAA1B,CAAJ,EAAwC;;AAExC,SAAKhG,gBAAL,CAAsBuI,GAAtB,CAA0BvC,OAA1B;;AAEA,UAAMwC,cAAc,GAAGxC,OAAO,CAAClB,IAAR,KAAiB,cAAxC;AACA,UAAM2D,aAAa,GAAGD,cAAc,IAAI,CAACL,YAAnB,IAAmC,CAAC,KAAKrI,iBAA/D;AACA,QAAI2I,aAAa,IAAI,KAAKrI,IAAL,CAAUmB,UAAV,EAArB,EAA6C,KAAKc,OAAL,CAAa,CAAb;AAC7C,UAAMqG,YAAY,GAAG,KAAKjH,WAAL,EAArB;;AAEA,QAAIiH,YAAY,KAAK,EAAjB,IAAuBA,YAAY,KAAK,GAA5C,EAAiD;AAC/C,WAAKrH,KAAL;AACD;;AAED,QAAIsH,GAAG,GAAG,CAACH,cAAD,IAAmB,CAAC,KAAK1I,iBAAzB,GAA8C,KAAIkG,OAAO,CAAC5H,KAAM,IAAhE,GAAuE,KAAI4H,OAAO,CAAC5H,KAAM,IAAnG;;AAEA,QAAIoK,cAAc,IAAI,KAAKjJ,MAAL,CAAYmB,MAAZ,CAAmBkI,sBAAzC,EAAiE;AAC/D,UAAIC,YAAJ;;AAEA,YAAMC,MAAM,GAAG,CAACD,YAAY,GAAG7C,OAAO,CAACjD,GAAxB,KAAgC,IAAhC,GAAuC,KAAK,CAA5C,GAAgD8F,YAAY,CAACE,KAAb,CAAmBC,MAAlF;;AAEA,UAAIF,MAAJ,EAAY;AACV,cAAMG,YAAY,GAAG,IAAIC,MAAJ,CAAW,cAAcJ,MAAd,GAAuB,GAAlC,EAAuC,GAAvC,CAArB;AACAH,QAAAA,GAAG,GAAGA,GAAG,CAACQ,OAAJ,CAAYF,YAAZ,EAA0B,IAA1B,CAAN;AACD;;AAED,YAAMG,UAAU,GAAGpB,IAAI,CAACqB,GAAL,CAAS,KAAK5F,UAAL,GAAkBvB,MAA3B,EAAmC,KAAK3C,MAAL,CAAYgD,WAAZ,GAA0B,CAA1B,GAA8B,KAAKnC,IAAL,CAAUkJ,gBAAV,EAAjE,CAAnB;AACAX,MAAAA,GAAG,GAAGA,GAAG,CAACQ,OAAJ,CAAY,UAAZ,EAAyB,KAAI,IAAI/E,MAAJ,CAAWgF,UAAX,CAAuB,EAApD,CAAN;AACD;;AAED,QAAI,KAAKxH,QAAL,CAAc,EAAd,CAAJ,EAAuB,KAAKN,MAAL;AACvB,SAAK8B,UAAL,CAAgB,OAAhB,EAAyB4C,OAAO,CAACjD,GAAjC,EAAsC,MAAM;AAC1C,WAAK/B,OAAL,CAAa2H,GAAb;AACD,KAFD;AAGA,QAAIF,aAAJ,EAAmB,KAAKpG,OAAL,CAAa,CAAb;AACpB;;AAED+E,EAAAA,cAAc,CAACmC,QAAD,EAAWC,oBAAX,EAAiC;AAC7C,QAAI,EAAED,QAAQ,IAAI,IAAZ,IAAoBA,QAAQ,CAACrH,MAA/B,CAAJ,EAA4C;;AAE5C,QAAIsH,oBAAoB,IAAID,QAAQ,CAACrH,MAAT,KAAoB,CAA5C,IAAiDpD,kBAAkB,CAACmD,IAAnB,CAAwBsH,QAAQ,CAAC,CAAD,CAAR,CAAYnL,KAApC,CAArD,EAAiG;AAC/F,WAAK8H,aAAL,CAAmBqD,QAAQ,CAAC,CAAD,CAA3B,EAAgC,KAAKnJ,IAAL,CAAUmB,UAAV,MAA0B,CAAC,KAAKK,QAAL,CAAc,EAAd,CAA3D;AACD,KAFD,MAEO;AACL,WAAK,MAAMoE,OAAX,IAAsBuD,QAAtB,EAAgC;AAC9B,aAAKrD,aAAL,CAAmBF,OAAnB;AACD;AACF;AACF;;AAEDyD,EAAAA,eAAe,CAAChF,IAAD,EAAO;AACpB,QAAIiF,gBAAJ;;AAEA,QAAI,CAACA,gBAAgB,GAAGjF,IAAI,CAACkF,UAAzB,KAAwC,IAAxC,IAAgDD,gBAAgB,CAACxH,MAArE,EAA6E;AAC3E,WAAKb,KAAL;AACA,WAAKK,IAAL,CAAU,QAAV;AACA,WAAKL,KAAL;AACA,WAAKD,KAAL,CAAW,GAAX;AACA,WAAKC,KAAL;AACA,WAAKqG,SAAL,CAAejD,IAAI,CAACkF,UAApB,EAAgClF,IAAhC;AACA,WAAKpD,KAAL;AACA,WAAKD,KAAL,CAAW,GAAX;AACD;AACF;;AA/eW;;AAmfdnD,MAAM,CAAC2L,MAAP,CAAcvK,OAAO,CAACwK,SAAtB,EAAiCnL,kBAAjC;AACA;AACEW,EAAAA,OAAO,CAACwK,SAAR,CAAkBC,IAAlB,GAAyB,SAASA,IAAT,GAAgB,CAAE,CAA3C;AACD;AACD,IAAIC,QAAQ,GAAG1K,OAAf;AACAlB,OAAO,CAACE,OAAR,GAAkB0L,QAAlB;;AAEA,SAASnC,cAAT,GAA0B;AACxB,OAAKxG,KAAL,CAAW,GAAX;AACA,OAAKC,KAAL;AACD","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _buffer = require(\"./buffer\");\n\nvar n = require(\"./node\");\n\nvar t = require(\"@babel/types\");\n\nvar generatorFunctions = require(\"./generators\");\n\nconst SCIENTIFIC_NOTATION = /e/i;\nconst ZERO_DECIMAL_INTEGER = /\\.0+$/;\nconst NON_DECIMAL_LITERAL = /^0[box]/;\nconst PURE_ANNOTATION_RE = /^\\s*[@#]__PURE__\\s*$/;\nconst {\n  isProgram,\n  isFile,\n  isEmptyStatement\n} = t;\nconst {\n  needsParens,\n  needsWhitespaceAfter,\n  needsWhitespaceBefore\n} = n;\n\nclass Printer {\n  constructor(format, map) {\n    this.inForStatementInitCounter = 0;\n    this._printStack = [];\n    this._indent = 0;\n    this._insideAux = false;\n    this._parenPushNewlineState = null;\n    this._noLineTerminator = false;\n    this._printAuxAfterOnNextUserNode = false;\n    this._printedComments = new WeakSet();\n    this._endsWithInteger = false;\n    this._endsWithWord = false;\n    this.format = format;\n    this._buf = new _buffer.default(map);\n  }\n\n  generate(ast) {\n    this.print(ast);\n\n    this._maybeAddAuxComment();\n\n    return this._buf.get();\n  }\n\n  indent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent++;\n  }\n\n  dedent() {\n    if (this.format.compact || this.format.concise) return;\n    this._indent--;\n  }\n\n  semicolon(force = false) {\n    this._maybeAddAuxComment();\n\n    this._append(\";\", !force);\n  }\n\n  rightBrace() {\n    if (this.format.minified) {\n      this._buf.removeLastSemicolon();\n    }\n\n    this.token(\"}\");\n  }\n\n  space(force = false) {\n    if (this.format.compact) return;\n\n    if (force) {\n      this._space();\n    } else if (this._buf.hasContent()) {\n      const lastCp = this.getLastChar();\n\n      if (lastCp !== 32 && lastCp !== 10) {\n        this._space();\n      }\n    }\n  }\n\n  word(str) {\n    if (this._endsWithWord || this.endsWith(47) && str.charCodeAt(0) === 47) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n\n    this._endsWithWord = true;\n  }\n\n  number(str) {\n    this.word(str);\n    this._endsWithInteger = Number.isInteger(+str) && !NON_DECIMAL_LITERAL.test(str) && !SCIENTIFIC_NOTATION.test(str) && !ZERO_DECIMAL_INTEGER.test(str) && str.charCodeAt(str.length - 1) !== 46;\n  }\n\n  token(str) {\n    const lastChar = this.getLastChar();\n    const strFirst = str.charCodeAt(0);\n\n    if (str === \"--\" && lastChar === 33 || strFirst === 43 && lastChar === 43 || strFirst === 45 && lastChar === 45 || strFirst === 46 && this._endsWithInteger) {\n      this._space();\n    }\n\n    this._maybeAddAuxComment();\n\n    this._append(str);\n  }\n\n  newline(i = 1) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    const charBeforeNewline = this.endsWithCharAndNewline();\n    if (charBeforeNewline === 10) return;\n\n    if (charBeforeNewline === 123 || charBeforeNewline === 58) {\n      i--;\n    }\n\n    if (i <= 0) return;\n\n    for (let j = 0; j < i; j++) {\n      this._newline();\n    }\n  }\n\n  endsWith(char) {\n    return this.getLastChar() === char;\n  }\n\n  getLastChar() {\n    return this._buf.getLastChar();\n  }\n\n  endsWithCharAndNewline() {\n    return this._buf.endsWithCharAndNewline();\n  }\n\n  removeTrailingNewline() {\n    this._buf.removeTrailingNewline();\n  }\n\n  exactSource(loc, cb) {\n    this._catchUp(\"start\", loc);\n\n    this._buf.exactSource(loc, cb);\n  }\n\n  source(prop, loc) {\n    this._catchUp(prop, loc);\n\n    this._buf.source(prop, loc);\n  }\n\n  withSource(prop, loc, cb) {\n    this._catchUp(prop, loc);\n\n    this._buf.withSource(prop, loc, cb);\n  }\n\n  _space() {\n    this._append(\" \", true);\n  }\n\n  _newline() {\n    this._append(\"\\n\", true);\n  }\n\n  _append(str, queue = false) {\n    this._maybeAddParen(str);\n\n    this._maybeIndent(str);\n\n    if (queue) this._buf.queue(str);else this._buf.append(str);\n    this._endsWithWord = false;\n    this._endsWithInteger = false;\n  }\n\n  _maybeIndent(str) {\n    if (this._indent && this.endsWith(10) && str.charCodeAt(0) !== 10) {\n      this._buf.queue(this._getIndent());\n    }\n  }\n\n  _maybeAddParen(str) {\n    const parenPushNewlineState = this._parenPushNewlineState;\n    if (!parenPushNewlineState) return;\n    let i;\n\n    for (i = 0; i < str.length && str[i] === \" \"; i++) continue;\n\n    if (i === str.length) {\n      return;\n    }\n\n    const cha = str[i];\n\n    if (cha !== \"\\n\") {\n      if (cha !== \"/\" || i + 1 === str.length) {\n        this._parenPushNewlineState = null;\n        return;\n      }\n\n      const chaPost = str[i + 1];\n\n      if (chaPost === \"*\") {\n        if (PURE_ANNOTATION_RE.test(str.slice(i + 2, str.length - 2))) {\n          return;\n        }\n      } else if (chaPost !== \"/\") {\n        this._parenPushNewlineState = null;\n        return;\n      }\n    }\n\n    this.token(\"(\");\n    this.indent();\n    parenPushNewlineState.printed = true;\n  }\n\n  _catchUp(prop, loc) {\n    if (!this.format.retainLines) return;\n    const pos = loc ? loc[prop] : null;\n\n    if ((pos == null ? void 0 : pos.line) != null) {\n      const count = pos.line - this._buf.getCurrentLine();\n\n      for (let i = 0; i < count; i++) {\n        this._newline();\n      }\n    }\n  }\n\n  _getIndent() {\n    return this.format.indent.style.repeat(this._indent);\n  }\n\n  startTerminatorless(isLabel = false) {\n    if (isLabel) {\n      this._noLineTerminator = true;\n      return null;\n    } else {\n      return this._parenPushNewlineState = {\n        printed: false\n      };\n    }\n  }\n\n  endTerminatorless(state) {\n    this._noLineTerminator = false;\n\n    if (state != null && state.printed) {\n      this.dedent();\n      this.newline();\n      this.token(\")\");\n    }\n  }\n\n  print(node, parent) {\n    if (!node) return;\n    const oldConcise = this.format.concise;\n\n    if (node._compact) {\n      this.format.concise = true;\n    }\n\n    const printMethod = this[node.type];\n\n    if (!printMethod) {\n      throw new ReferenceError(`unknown node of type ${JSON.stringify(node.type)} with constructor ${JSON.stringify(node == null ? void 0 : node.constructor.name)}`);\n    }\n\n    this._printStack.push(node);\n\n    const oldInAux = this._insideAux;\n    this._insideAux = !node.loc;\n\n    this._maybeAddAuxComment(this._insideAux && !oldInAux);\n\n    let shouldPrintParens = needsParens(node, parent, this._printStack);\n\n    if (this.format.retainFunctionParens && node.type === \"FunctionExpression\" && node.extra && node.extra.parenthesized) {\n      shouldPrintParens = true;\n    }\n\n    if (shouldPrintParens) this.token(\"(\");\n\n    this._printLeadingComments(node);\n\n    const loc = isProgram(node) || isFile(node) ? null : node.loc;\n    this.withSource(\"start\", loc, () => {\n      printMethod.call(this, node, parent);\n    });\n\n    this._printTrailingComments(node);\n\n    if (shouldPrintParens) this.token(\")\");\n\n    this._printStack.pop();\n\n    this.format.concise = oldConcise;\n    this._insideAux = oldInAux;\n  }\n\n  _maybeAddAuxComment(enteredPositionlessNode) {\n    if (enteredPositionlessNode) this._printAuxBeforeComment();\n    if (!this._insideAux) this._printAuxAfterComment();\n  }\n\n  _printAuxBeforeComment() {\n    if (this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = true;\n    const comment = this.format.auxiliaryCommentBefore;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  _printAuxAfterComment() {\n    if (!this._printAuxAfterOnNextUserNode) return;\n    this._printAuxAfterOnNextUserNode = false;\n    const comment = this.format.auxiliaryCommentAfter;\n\n    if (comment) {\n      this._printComment({\n        type: \"CommentBlock\",\n        value: comment\n      });\n    }\n  }\n\n  getPossibleRaw(node) {\n    const extra = node.extra;\n\n    if (extra && extra.raw != null && extra.rawValue != null && node.value === extra.rawValue) {\n      return extra.raw;\n    }\n  }\n\n  printJoin(nodes, parent, opts = {}) {\n    if (!(nodes != null && nodes.length)) return;\n    if (opts.indent) this.indent();\n    const newlineOpts = {\n      addNewlines: opts.addNewlines\n    };\n\n    for (let i = 0; i < nodes.length; i++) {\n      const node = nodes[i];\n      if (!node) continue;\n      if (opts.statement) this._printNewline(true, node, parent, newlineOpts);\n      this.print(node, parent);\n\n      if (opts.iterator) {\n        opts.iterator(node, i);\n      }\n\n      if (opts.separator && i < nodes.length - 1) {\n        opts.separator.call(this);\n      }\n\n      if (opts.statement) this._printNewline(false, node, parent, newlineOpts);\n    }\n\n    if (opts.indent) this.dedent();\n  }\n\n  printAndIndentOnComments(node, parent) {\n    const indent = node.leadingComments && node.leadingComments.length > 0;\n    if (indent) this.indent();\n    this.print(node, parent);\n    if (indent) this.dedent();\n  }\n\n  printBlock(parent) {\n    const node = parent.body;\n\n    if (!isEmptyStatement(node)) {\n      this.space();\n    }\n\n    this.print(node, parent);\n  }\n\n  _printTrailingComments(node) {\n    this._printComments(this._getComments(false, node));\n  }\n\n  _printLeadingComments(node) {\n    this._printComments(this._getComments(true, node), true);\n  }\n\n  printInnerComments(node, indent = true) {\n    var _node$innerComments;\n\n    if (!((_node$innerComments = node.innerComments) != null && _node$innerComments.length)) return;\n    if (indent) this.indent();\n\n    this._printComments(node.innerComments);\n\n    if (indent) this.dedent();\n  }\n\n  printSequence(nodes, parent, opts = {}) {\n    opts.statement = true;\n    return this.printJoin(nodes, parent, opts);\n  }\n\n  printList(items, parent, opts = {}) {\n    if (opts.separator == null) {\n      opts.separator = commaSeparator;\n    }\n\n    return this.printJoin(items, parent, opts);\n  }\n\n  _printNewline(leading, node, parent, opts) {\n    if (this.format.retainLines || this.format.compact) return;\n\n    if (this.format.concise) {\n      this.space();\n      return;\n    }\n\n    let lines = 0;\n\n    if (this._buf.hasContent()) {\n      if (!leading) lines++;\n      if (opts.addNewlines) lines += opts.addNewlines(leading, node) || 0;\n      const needs = leading ? needsWhitespaceBefore : needsWhitespaceAfter;\n      if (needs(node, parent)) lines++;\n    }\n\n    this.newline(Math.min(2, lines));\n  }\n\n  _getComments(leading, node) {\n    return node && (leading ? node.leadingComments : node.trailingComments) || [];\n  }\n\n  _printComment(comment, skipNewLines) {\n    if (!this.format.shouldPrintComment(comment.value)) return;\n    if (comment.ignore) return;\n    if (this._printedComments.has(comment)) return;\n\n    this._printedComments.add(comment);\n\n    const isBlockComment = comment.type === \"CommentBlock\";\n    const printNewLines = isBlockComment && !skipNewLines && !this._noLineTerminator;\n    if (printNewLines && this._buf.hasContent()) this.newline(1);\n    const lastCharCode = this.getLastChar();\n\n    if (lastCharCode !== 91 && lastCharCode !== 123) {\n      this.space();\n    }\n\n    let val = !isBlockComment && !this._noLineTerminator ? `//${comment.value}\\n` : `/*${comment.value}*/`;\n\n    if (isBlockComment && this.format.indent.adjustMultilineComment) {\n      var _comment$loc;\n\n      const offset = (_comment$loc = comment.loc) == null ? void 0 : _comment$loc.start.column;\n\n      if (offset) {\n        const newlineRegex = new RegExp(\"\\\\n\\\\s{1,\" + offset + \"}\", \"g\");\n        val = val.replace(newlineRegex, \"\\n\");\n      }\n\n      const indentSize = Math.max(this._getIndent().length, this.format.retainLines ? 0 : this._buf.getCurrentColumn());\n      val = val.replace(/\\n(?!$)/g, `\\n${\" \".repeat(indentSize)}`);\n    }\n\n    if (this.endsWith(47)) this._space();\n    this.withSource(\"start\", comment.loc, () => {\n      this._append(val);\n    });\n    if (printNewLines) this.newline(1);\n  }\n\n  _printComments(comments, inlinePureAnnotation) {\n    if (!(comments != null && comments.length)) return;\n\n    if (inlinePureAnnotation && comments.length === 1 && PURE_ANNOTATION_RE.test(comments[0].value)) {\n      this._printComment(comments[0], this._buf.hasContent() && !this.endsWith(10));\n    } else {\n      for (const comment of comments) {\n        this._printComment(comment);\n      }\n    }\n  }\n\n  printAssertions(node) {\n    var _node$assertions;\n\n    if ((_node$assertions = node.assertions) != null && _node$assertions.length) {\n      this.space();\n      this.word(\"assert\");\n      this.space();\n      this.token(\"{\");\n      this.space();\n      this.printList(node.assertions, node);\n      this.space();\n      this.token(\"}\");\n    }\n  }\n\n}\n\nObject.assign(Printer.prototype, generatorFunctions);\n{\n  Printer.prototype.Noop = function Noop() {};\n}\nvar _default = Printer;\nexports.default = _default;\n\nfunction commaSeparator() {\n  this.token(\",\");\n  this.space();\n}"]},"metadata":{},"sourceType":"script"}