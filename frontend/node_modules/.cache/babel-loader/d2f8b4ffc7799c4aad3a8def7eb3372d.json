{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = splitExportDeclaration;\n\nvar t = require(\"@babel/types\");\n\nfunction splitExportDeclaration(exportDeclaration) {\n  if (!exportDeclaration.isExportDeclaration()) {\n    throw new Error(\"Only export declarations can be split.\");\n  }\n\n  const isDefault = exportDeclaration.isExportDefaultDeclaration();\n  const declaration = exportDeclaration.get(\"declaration\");\n  const isClassDeclaration = declaration.isClassDeclaration();\n\n  if (isDefault) {\n    const standaloneDeclaration = declaration.isFunctionDeclaration() || isClassDeclaration;\n    const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;\n    let id = declaration.node.id;\n    let needBindingRegistration = false;\n\n    if (!id) {\n      needBindingRegistration = true;\n      id = scope.generateUidIdentifier(\"default\");\n\n      if (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) {\n        declaration.node.id = t.cloneNode(id);\n      }\n    }\n\n    const updatedDeclaration = standaloneDeclaration ? declaration : t.variableDeclaration(\"var\", [t.variableDeclarator(t.cloneNode(id), declaration.node)]);\n    const updatedExportDeclaration = t.exportNamedDeclaration(null, [t.exportSpecifier(t.cloneNode(id), t.identifier(\"default\"))]);\n    exportDeclaration.insertAfter(updatedExportDeclaration);\n    exportDeclaration.replaceWith(updatedDeclaration);\n\n    if (needBindingRegistration) {\n      scope.registerDeclaration(exportDeclaration);\n    }\n\n    return exportDeclaration;\n  }\n\n  if (exportDeclaration.get(\"specifiers\").length > 0) {\n    throw new Error(\"It doesn't make sense to split exported specifiers.\");\n  }\n\n  const bindingIdentifiers = declaration.getOuterBindingIdentifiers();\n  const specifiers = Object.keys(bindingIdentifiers).map(name => {\n    return t.exportSpecifier(t.identifier(name), t.identifier(name));\n  });\n  const aliasDeclar = t.exportNamedDeclaration(null, specifiers);\n  exportDeclaration.insertAfter(aliasDeclar);\n  exportDeclaration.replaceWith(declaration.node);\n  return exportDeclaration;\n}","map":{"version":3,"sources":["/Users/alperenalkan/obss/frontend/frontend/node_modules/@babel/helper-split-export-declaration/lib/index.js"],"names":["Object","defineProperty","exports","value","default","splitExportDeclaration","t","require","exportDeclaration","isExportDeclaration","Error","isDefault","isExportDefaultDeclaration","declaration","get","isClassDeclaration","standaloneDeclaration","isFunctionDeclaration","scope","isScope","parent","id","node","needBindingRegistration","generateUidIdentifier","isFunctionExpression","isClassExpression","cloneNode","updatedDeclaration","variableDeclaration","variableDeclarator","updatedExportDeclaration","exportNamedDeclaration","exportSpecifier","identifier","insertAfter","replaceWith","registerDeclaration","length","bindingIdentifiers","getOuterBindingIdentifiers","specifiers","keys","map","name","aliasDeclar"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = splitExportDeclaration;\n\nvar t = require(\"@babel/types\");\n\nfunction splitExportDeclaration(exportDeclaration) {\n  if (!exportDeclaration.isExportDeclaration()) {\n    throw new Error(\"Only export declarations can be split.\");\n  }\n\n  const isDefault = exportDeclaration.isExportDefaultDeclaration();\n  const declaration = exportDeclaration.get(\"declaration\");\n  const isClassDeclaration = declaration.isClassDeclaration();\n\n  if (isDefault) {\n    const standaloneDeclaration = declaration.isFunctionDeclaration() || isClassDeclaration;\n    const scope = declaration.isScope() ? declaration.scope.parent : declaration.scope;\n    let id = declaration.node.id;\n    let needBindingRegistration = false;\n\n    if (!id) {\n      needBindingRegistration = true;\n      id = scope.generateUidIdentifier(\"default\");\n\n      if (standaloneDeclaration || declaration.isFunctionExpression() || declaration.isClassExpression()) {\n        declaration.node.id = t.cloneNode(id);\n      }\n    }\n\n    const updatedDeclaration = standaloneDeclaration ? declaration : t.variableDeclaration(\"var\", [t.variableDeclarator(t.cloneNode(id), declaration.node)]);\n    const updatedExportDeclaration = t.exportNamedDeclaration(null, [t.exportSpecifier(t.cloneNode(id), t.identifier(\"default\"))]);\n    exportDeclaration.insertAfter(updatedExportDeclaration);\n    exportDeclaration.replaceWith(updatedDeclaration);\n\n    if (needBindingRegistration) {\n      scope.registerDeclaration(exportDeclaration);\n    }\n\n    return exportDeclaration;\n  }\n\n  if (exportDeclaration.get(\"specifiers\").length > 0) {\n    throw new Error(\"It doesn't make sense to split exported specifiers.\");\n  }\n\n  const bindingIdentifiers = declaration.getOuterBindingIdentifiers();\n  const specifiers = Object.keys(bindingIdentifiers).map(name => {\n    return t.exportSpecifier(t.identifier(name), t.identifier(name));\n  });\n  const aliasDeclar = t.exportNamedDeclaration(null, specifiers);\n  exportDeclaration.insertAfter(aliasDeclar);\n  exportDeclaration.replaceWith(declaration.node);\n  return exportDeclaration;\n}"]},"metadata":{},"sourceType":"script"}