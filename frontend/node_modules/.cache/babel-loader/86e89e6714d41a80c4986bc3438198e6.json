{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.verify = verify;\nexports.merge = merge;\n\nvar virtualTypes = require(\"./path/lib/virtual-types\");\n\nvar t = require(\"@babel/types\");\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      for (const type of wrapper.types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = t.FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecatedKey = t.DEPRECATED_KEYS[nodeType];\n\n    if (deprecatedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`);\n      aliases = [deprecatedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (t.TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors, states = [], wrapper) {\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  const newFn = function (path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\" || key === \"blacklist\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}","map":{"version":3,"sources":["/Users/alperenalkan/obss/frontend/frontend/node_modules/@babel/traverse/lib/visitors.js"],"names":["Object","defineProperty","exports","value","explode","verify","merge","virtualTypes","require","t","visitor","_exploded","nodeType","keys","shouldIgnoreKey","parts","split","length","fns","part","__esModule","ensureEntranceObjects","ensureCallbackArrays","wrapper","type","wrapCheck","types","mergePair","aliases","FLIPPED_ALIAS_KEYS","deprecatedKey","DEPRECATED_KEYS","console","trace","alias","existing","assign","_verified","Error","validateVisitorMethods","TYPES","indexOf","visitors","visitorKey","path","val","concat","fn","TypeError","states","rootVisitor","i","state","visitorType","wrapWithStateOrWrapper","nodeVisitor","oldVisitor","newVisitor","key","Array","isArray","map","newFn","call","toString","obj","enter","exit","checkPath","apply","arguments","dest","src"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.explode = explode;\nexports.verify = verify;\nexports.merge = merge;\n\nvar virtualTypes = require(\"./path/lib/virtual-types\");\n\nvar t = require(\"@babel/types\");\n\nfunction explode(visitor) {\n  if (visitor._exploded) return visitor;\n  visitor._exploded = true;\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const parts = nodeType.split(\"|\");\n    if (parts.length === 1) continue;\n    const fns = visitor[nodeType];\n    delete visitor[nodeType];\n\n    for (const part of parts) {\n      visitor[part] = fns;\n    }\n  }\n\n  verify(visitor);\n  delete visitor.__esModule;\n  ensureEntranceObjects(visitor);\n  ensureCallbackArrays(visitor);\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const wrapper = virtualTypes[nodeType];\n    if (!wrapper) continue;\n    const fns = visitor[nodeType];\n\n    for (const type of Object.keys(fns)) {\n      fns[type] = wrapCheck(wrapper, fns[type]);\n    }\n\n    delete visitor[nodeType];\n\n    if (wrapper.types) {\n      for (const type of wrapper.types) {\n        if (visitor[type]) {\n          mergePair(visitor[type], fns);\n        } else {\n          visitor[type] = fns;\n        }\n      }\n    } else {\n      mergePair(visitor, fns);\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    const fns = visitor[nodeType];\n    let aliases = t.FLIPPED_ALIAS_KEYS[nodeType];\n    const deprecatedKey = t.DEPRECATED_KEYS[nodeType];\n\n    if (deprecatedKey) {\n      console.trace(`Visitor defined for ${nodeType} but it has been renamed to ${deprecatedKey}`);\n      aliases = [deprecatedKey];\n    }\n\n    if (!aliases) continue;\n    delete visitor[nodeType];\n\n    for (const alias of aliases) {\n      const existing = visitor[alias];\n\n      if (existing) {\n        mergePair(existing, fns);\n      } else {\n        visitor[alias] = Object.assign({}, fns);\n      }\n    }\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (shouldIgnoreKey(nodeType)) continue;\n    ensureCallbackArrays(visitor[nodeType]);\n  }\n\n  return visitor;\n}\n\nfunction verify(visitor) {\n  if (visitor._verified) return;\n\n  if (typeof visitor === \"function\") {\n    throw new Error(\"You passed `traverse()` a function when it expected a visitor object, \" + \"are you sure you didn't mean `{ enter: Function }`?\");\n  }\n\n  for (const nodeType of Object.keys(visitor)) {\n    if (nodeType === \"enter\" || nodeType === \"exit\") {\n      validateVisitorMethods(nodeType, visitor[nodeType]);\n    }\n\n    if (shouldIgnoreKey(nodeType)) continue;\n\n    if (t.TYPES.indexOf(nodeType) < 0) {\n      throw new Error(`You gave us a visitor for the node type ${nodeType} but it's not a valid type`);\n    }\n\n    const visitors = visitor[nodeType];\n\n    if (typeof visitors === \"object\") {\n      for (const visitorKey of Object.keys(visitors)) {\n        if (visitorKey === \"enter\" || visitorKey === \"exit\") {\n          validateVisitorMethods(`${nodeType}.${visitorKey}`, visitors[visitorKey]);\n        } else {\n          throw new Error(\"You passed `traverse()` a visitor object with the property \" + `${nodeType} that has the invalid property ${visitorKey}`);\n        }\n      }\n    }\n  }\n\n  visitor._verified = true;\n}\n\nfunction validateVisitorMethods(path, val) {\n  const fns = [].concat(val);\n\n  for (const fn of fns) {\n    if (typeof fn !== \"function\") {\n      throw new TypeError(`Non-function found defined in ${path} with type ${typeof fn}`);\n    }\n  }\n}\n\nfunction merge(visitors, states = [], wrapper) {\n  const rootVisitor = {};\n\n  for (let i = 0; i < visitors.length; i++) {\n    const visitor = visitors[i];\n    const state = states[i];\n    explode(visitor);\n\n    for (const type of Object.keys(visitor)) {\n      let visitorType = visitor[type];\n\n      if (state || wrapper) {\n        visitorType = wrapWithStateOrWrapper(visitorType, state, wrapper);\n      }\n\n      const nodeVisitor = rootVisitor[type] = rootVisitor[type] || {};\n      mergePair(nodeVisitor, visitorType);\n    }\n  }\n\n  return rootVisitor;\n}\n\nfunction wrapWithStateOrWrapper(oldVisitor, state, wrapper) {\n  const newVisitor = {};\n\n  for (const key of Object.keys(oldVisitor)) {\n    let fns = oldVisitor[key];\n    if (!Array.isArray(fns)) continue;\n    fns = fns.map(function (fn) {\n      let newFn = fn;\n\n      if (state) {\n        newFn = function (path) {\n          return fn.call(state, path, state);\n        };\n      }\n\n      if (wrapper) {\n        newFn = wrapper(state.key, key, newFn);\n      }\n\n      if (newFn !== fn) {\n        newFn.toString = () => fn.toString();\n      }\n\n      return newFn;\n    });\n    newVisitor[key] = fns;\n  }\n\n  return newVisitor;\n}\n\nfunction ensureEntranceObjects(obj) {\n  for (const key of Object.keys(obj)) {\n    if (shouldIgnoreKey(key)) continue;\n    const fns = obj[key];\n\n    if (typeof fns === \"function\") {\n      obj[key] = {\n        enter: fns\n      };\n    }\n  }\n}\n\nfunction ensureCallbackArrays(obj) {\n  if (obj.enter && !Array.isArray(obj.enter)) obj.enter = [obj.enter];\n  if (obj.exit && !Array.isArray(obj.exit)) obj.exit = [obj.exit];\n}\n\nfunction wrapCheck(wrapper, fn) {\n  const newFn = function (path) {\n    if (wrapper.checkPath(path)) {\n      return fn.apply(this, arguments);\n    }\n  };\n\n  newFn.toString = () => fn.toString();\n\n  return newFn;\n}\n\nfunction shouldIgnoreKey(key) {\n  if (key[0] === \"_\") return true;\n  if (key === \"enter\" || key === \"exit\" || key === \"shouldSkip\") return true;\n\n  if (key === \"denylist\" || key === \"noScope\" || key === \"skipKeys\" || key === \"blacklist\") {\n    return true;\n  }\n\n  return false;\n}\n\nfunction mergePair(dest, src) {\n  for (const key of Object.keys(src)) {\n    dest[key] = [].concat(dest[key] || [], src[key]);\n  }\n}"]},"metadata":{},"sourceType":"script"}