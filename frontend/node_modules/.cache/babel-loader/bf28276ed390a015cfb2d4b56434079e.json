{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nconst SPACES_RE = /^[ \\t]+$/;\n\nclass Buffer {\n  constructor(map) {\n    this._map = null;\n    this._buf = \"\";\n    this._last = 0;\n    this._queue = [];\n    this._position = {\n      line: 1,\n      column: 0\n    };\n    this._sourcePosition = {\n      identifierName: null,\n      line: null,\n      column: null,\n      filename: null\n    };\n    this._disallowedPop = null;\n    this._map = map;\n  }\n\n  get() {\n    this._flush();\n\n    const map = this._map;\n    const result = {\n      code: this._buf.trimRight(),\n      map: null,\n      rawMappings: map == null ? void 0 : map.getRawMappings()\n    };\n\n    if (map) {\n      Object.defineProperty(result, \"map\", {\n        configurable: true,\n        enumerable: true,\n\n        get() {\n          return this.map = map.get();\n        },\n\n        set(value) {\n          Object.defineProperty(this, \"map\", {\n            value,\n            writable: true\n          });\n        }\n\n      });\n    }\n\n    return result;\n  }\n\n  append(str) {\n    this._flush();\n\n    const {\n      line,\n      column,\n      filename,\n      identifierName,\n      force\n    } = this._sourcePosition;\n\n    this._append(str, line, column, identifierName, filename, force);\n  }\n\n  queue(str) {\n    if (str === \"\\n\") {\n      while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {\n        this._queue.shift();\n      }\n    }\n\n    const {\n      line,\n      column,\n      filename,\n      identifierName,\n      force\n    } = this._sourcePosition;\n\n    this._queue.unshift([str, line, column, identifierName, filename, force]);\n  }\n\n  _flush() {\n    let item;\n\n    while (item = this._queue.pop()) {\n      this._append(...item);\n    }\n  }\n\n  _append(str, line, column, identifierName, filename, force) {\n    this._buf += str;\n    this._last = str.charCodeAt(str.length - 1);\n    let i = str.indexOf(\"\\n\");\n    let last = 0;\n\n    if (i !== 0) {\n      this._mark(line, column, identifierName, filename, force);\n    }\n\n    while (i !== -1) {\n      this._position.line++;\n      this._position.column = 0;\n      last = i + 1;\n\n      if (last < str.length) {\n        this._mark(++line, 0, identifierName, filename, force);\n      }\n\n      i = str.indexOf(\"\\n\", last);\n    }\n\n    this._position.column += str.length - last;\n  }\n\n  _mark(line, column, identifierName, filename, force) {\n    var _this$_map;\n\n    (_this$_map = this._map) == null ? void 0 : _this$_map.mark(this._position.line, this._position.column, line, column, identifierName, filename, force);\n  }\n\n  removeTrailingNewline() {\n    if (this._queue.length > 0 && this._queue[0][0] === \"\\n\") {\n      this._queue.shift();\n    }\n  }\n\n  removeLastSemicolon() {\n    if (this._queue.length > 0 && this._queue[0][0] === \";\") {\n      this._queue.shift();\n    }\n  }\n\n  getLastChar() {\n    let last;\n\n    if (this._queue.length > 0) {\n      const str = this._queue[0][0];\n      last = str.charCodeAt(0);\n    } else {\n      last = this._last;\n    }\n\n    return last;\n  }\n\n  endsWithCharAndNewline() {\n    const queue = this._queue;\n\n    if (queue.length > 0) {\n      const last = queue[0][0];\n      const lastCp = last.charCodeAt(0);\n      if (lastCp !== 10) return;\n\n      if (queue.length > 1) {\n        const secondLast = queue[1][0];\n        return secondLast.charCodeAt(0);\n      } else {\n        return this._last;\n      }\n    }\n  }\n\n  hasContent() {\n    return this._queue.length > 0 || !!this._last;\n  }\n\n  exactSource(loc, cb) {\n    this.source(\"start\", loc, true);\n    cb();\n    this.source(\"end\", loc);\n\n    this._disallowPop(\"start\", loc);\n  }\n\n  source(prop, loc, force) {\n    if (prop && !loc) return;\n\n    this._normalizePosition(prop, loc, this._sourcePosition, force);\n  }\n\n  withSource(prop, loc, cb) {\n    if (!this._map) return cb();\n    const originalLine = this._sourcePosition.line;\n    const originalColumn = this._sourcePosition.column;\n    const originalFilename = this._sourcePosition.filename;\n    const originalIdentifierName = this._sourcePosition.identifierName;\n    this.source(prop, loc);\n    cb();\n\n    if ((!this._sourcePosition.force || this._sourcePosition.line !== originalLine || this._sourcePosition.column !== originalColumn || this._sourcePosition.filename !== originalFilename) && (!this._disallowedPop || this._disallowedPop.line !== originalLine || this._disallowedPop.column !== originalColumn || this._disallowedPop.filename !== originalFilename)) {\n      this._sourcePosition.line = originalLine;\n      this._sourcePosition.column = originalColumn;\n      this._sourcePosition.filename = originalFilename;\n      this._sourcePosition.identifierName = originalIdentifierName;\n      this._sourcePosition.force = false;\n      this._disallowedPop = null;\n    }\n  }\n\n  _disallowPop(prop, loc) {\n    if (prop && !loc) return;\n    this._disallowedPop = this._normalizePosition(prop, loc);\n  }\n\n  _normalizePosition(prop, loc, targetObj, force) {\n    const pos = loc ? loc[prop] : null;\n\n    if (targetObj === undefined) {\n      targetObj = {\n        identifierName: null,\n        line: null,\n        column: null,\n        filename: null,\n        force: false\n      };\n    }\n\n    const origLine = targetObj.line;\n    const origColumn = targetObj.column;\n    const origFilename = targetObj.filename;\n    targetObj.identifierName = prop === \"start\" && (loc == null ? void 0 : loc.identifierName) || null;\n    targetObj.line = pos == null ? void 0 : pos.line;\n    targetObj.column = pos == null ? void 0 : pos.column;\n    targetObj.filename = loc == null ? void 0 : loc.filename;\n\n    if (force || targetObj.line !== origLine || targetObj.column !== origColumn || targetObj.filename !== origFilename) {\n      targetObj.force = force;\n    }\n\n    return targetObj;\n  }\n\n  getCurrentColumn() {\n    const extra = this._queue.reduce((acc, item) => item[0] + acc, \"\");\n\n    const lastIndex = extra.lastIndexOf(\"\\n\");\n    return lastIndex === -1 ? this._position.column + extra.length : extra.length - 1 - lastIndex;\n  }\n\n  getCurrentLine() {\n    const extra = this._queue.reduce((acc, item) => item[0] + acc, \"\");\n\n    let count = 0;\n\n    for (let i = 0; i < extra.length; i++) {\n      if (extra[i] === \"\\n\") count++;\n    }\n\n    return this._position.line + count;\n  }\n\n}\n\nexports.default = Buffer;","map":{"version":3,"sources":["/Users/alperenalkan/obss/frontend/frontend/node_modules/@babel/generator/lib/buffer.js"],"names":["Object","defineProperty","exports","value","default","SPACES_RE","Buffer","constructor","map","_map","_buf","_last","_queue","_position","line","column","_sourcePosition","identifierName","filename","_disallowedPop","get","_flush","result","code","trimRight","rawMappings","getRawMappings","configurable","enumerable","set","writable","append","str","force","_append","queue","length","test","shift","unshift","item","pop","charCodeAt","i","indexOf","last","_mark","_this$_map","mark","removeTrailingNewline","removeLastSemicolon","getLastChar","endsWithCharAndNewline","lastCp","secondLast","hasContent","exactSource","loc","cb","source","_disallowPop","prop","_normalizePosition","withSource","originalLine","originalColumn","originalFilename","originalIdentifierName","targetObj","pos","undefined","origLine","origColumn","origFilename","getCurrentColumn","extra","reduce","acc","lastIndex","lastIndexOf","getCurrentLine","count"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nconst SPACES_RE = /^[ \\t]+$/;\n\nclass Buffer {\n  constructor(map) {\n    this._map = null;\n    this._buf = \"\";\n    this._last = 0;\n    this._queue = [];\n    this._position = {\n      line: 1,\n      column: 0\n    };\n    this._sourcePosition = {\n      identifierName: null,\n      line: null,\n      column: null,\n      filename: null\n    };\n    this._disallowedPop = null;\n    this._map = map;\n  }\n\n  get() {\n    this._flush();\n\n    const map = this._map;\n    const result = {\n      code: this._buf.trimRight(),\n      map: null,\n      rawMappings: map == null ? void 0 : map.getRawMappings()\n    };\n\n    if (map) {\n      Object.defineProperty(result, \"map\", {\n        configurable: true,\n        enumerable: true,\n\n        get() {\n          return this.map = map.get();\n        },\n\n        set(value) {\n          Object.defineProperty(this, \"map\", {\n            value,\n            writable: true\n          });\n        }\n\n      });\n    }\n\n    return result;\n  }\n\n  append(str) {\n    this._flush();\n\n    const {\n      line,\n      column,\n      filename,\n      identifierName,\n      force\n    } = this._sourcePosition;\n\n    this._append(str, line, column, identifierName, filename, force);\n  }\n\n  queue(str) {\n    if (str === \"\\n\") {\n      while (this._queue.length > 0 && SPACES_RE.test(this._queue[0][0])) {\n        this._queue.shift();\n      }\n    }\n\n    const {\n      line,\n      column,\n      filename,\n      identifierName,\n      force\n    } = this._sourcePosition;\n\n    this._queue.unshift([str, line, column, identifierName, filename, force]);\n  }\n\n  _flush() {\n    let item;\n\n    while (item = this._queue.pop()) {\n      this._append(...item);\n    }\n  }\n\n  _append(str, line, column, identifierName, filename, force) {\n    this._buf += str;\n    this._last = str.charCodeAt(str.length - 1);\n    let i = str.indexOf(\"\\n\");\n    let last = 0;\n\n    if (i !== 0) {\n      this._mark(line, column, identifierName, filename, force);\n    }\n\n    while (i !== -1) {\n      this._position.line++;\n      this._position.column = 0;\n      last = i + 1;\n\n      if (last < str.length) {\n        this._mark(++line, 0, identifierName, filename, force);\n      }\n\n      i = str.indexOf(\"\\n\", last);\n    }\n\n    this._position.column += str.length - last;\n  }\n\n  _mark(line, column, identifierName, filename, force) {\n    var _this$_map;\n\n    (_this$_map = this._map) == null ? void 0 : _this$_map.mark(this._position.line, this._position.column, line, column, identifierName, filename, force);\n  }\n\n  removeTrailingNewline() {\n    if (this._queue.length > 0 && this._queue[0][0] === \"\\n\") {\n      this._queue.shift();\n    }\n  }\n\n  removeLastSemicolon() {\n    if (this._queue.length > 0 && this._queue[0][0] === \";\") {\n      this._queue.shift();\n    }\n  }\n\n  getLastChar() {\n    let last;\n\n    if (this._queue.length > 0) {\n      const str = this._queue[0][0];\n      last = str.charCodeAt(0);\n    } else {\n      last = this._last;\n    }\n\n    return last;\n  }\n\n  endsWithCharAndNewline() {\n    const queue = this._queue;\n\n    if (queue.length > 0) {\n      const last = queue[0][0];\n      const lastCp = last.charCodeAt(0);\n      if (lastCp !== 10) return;\n\n      if (queue.length > 1) {\n        const secondLast = queue[1][0];\n        return secondLast.charCodeAt(0);\n      } else {\n        return this._last;\n      }\n    }\n  }\n\n  hasContent() {\n    return this._queue.length > 0 || !!this._last;\n  }\n\n  exactSource(loc, cb) {\n    this.source(\"start\", loc, true);\n    cb();\n    this.source(\"end\", loc);\n\n    this._disallowPop(\"start\", loc);\n  }\n\n  source(prop, loc, force) {\n    if (prop && !loc) return;\n\n    this._normalizePosition(prop, loc, this._sourcePosition, force);\n  }\n\n  withSource(prop, loc, cb) {\n    if (!this._map) return cb();\n    const originalLine = this._sourcePosition.line;\n    const originalColumn = this._sourcePosition.column;\n    const originalFilename = this._sourcePosition.filename;\n    const originalIdentifierName = this._sourcePosition.identifierName;\n    this.source(prop, loc);\n    cb();\n\n    if ((!this._sourcePosition.force || this._sourcePosition.line !== originalLine || this._sourcePosition.column !== originalColumn || this._sourcePosition.filename !== originalFilename) && (!this._disallowedPop || this._disallowedPop.line !== originalLine || this._disallowedPop.column !== originalColumn || this._disallowedPop.filename !== originalFilename)) {\n      this._sourcePosition.line = originalLine;\n      this._sourcePosition.column = originalColumn;\n      this._sourcePosition.filename = originalFilename;\n      this._sourcePosition.identifierName = originalIdentifierName;\n      this._sourcePosition.force = false;\n      this._disallowedPop = null;\n    }\n  }\n\n  _disallowPop(prop, loc) {\n    if (prop && !loc) return;\n    this._disallowedPop = this._normalizePosition(prop, loc);\n  }\n\n  _normalizePosition(prop, loc, targetObj, force) {\n    const pos = loc ? loc[prop] : null;\n\n    if (targetObj === undefined) {\n      targetObj = {\n        identifierName: null,\n        line: null,\n        column: null,\n        filename: null,\n        force: false\n      };\n    }\n\n    const origLine = targetObj.line;\n    const origColumn = targetObj.column;\n    const origFilename = targetObj.filename;\n    targetObj.identifierName = prop === \"start\" && (loc == null ? void 0 : loc.identifierName) || null;\n    targetObj.line = pos == null ? void 0 : pos.line;\n    targetObj.column = pos == null ? void 0 : pos.column;\n    targetObj.filename = loc == null ? void 0 : loc.filename;\n\n    if (force || targetObj.line !== origLine || targetObj.column !== origColumn || targetObj.filename !== origFilename) {\n      targetObj.force = force;\n    }\n\n    return targetObj;\n  }\n\n  getCurrentColumn() {\n    const extra = this._queue.reduce((acc, item) => item[0] + acc, \"\");\n\n    const lastIndex = extra.lastIndexOf(\"\\n\");\n    return lastIndex === -1 ? this._position.column + extra.length : extra.length - 1 - lastIndex;\n  }\n\n  getCurrentLine() {\n    const extra = this._queue.reduce((acc, item) => item[0] + acc, \"\");\n\n    let count = 0;\n\n    for (let i = 0; i < extra.length; i++) {\n      if (extra[i] === \"\\n\") count++;\n    }\n\n    return this._position.line + count;\n  }\n\n}\n\nexports.default = Buffer;"]},"metadata":{},"sourceType":"script"}