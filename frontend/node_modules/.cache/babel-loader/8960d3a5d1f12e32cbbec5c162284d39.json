{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _gensync() {\n  const data = _interopRequireDefault(require(\"gensync\"));\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _async = require(\"../gensync-utils/async\");\n\nvar _util = require(\"./util\");\n\nvar context = _interopRequireWildcard(require(\"../index\"));\n\nvar _plugin = _interopRequireDefault(require(\"./plugin\"));\n\nvar _item = require(\"./item\");\n\nvar _configChain = require(\"./config-chain\");\n\nfunction _traverse() {\n  const data = _interopRequireDefault(require(\"@babel/traverse\"));\n\n  _traverse = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _caching = require(\"./caching\");\n\nvar _options = require(\"./validation/options\");\n\nvar _plugins = require(\"./validation/plugins\");\n\nvar _configApi = _interopRequireDefault(require(\"./helpers/config-api\"));\n\nvar _partial = _interopRequireDefault(require(\"./partial\"));\n\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n\n  _getRequireWildcardCache = function () {\n    return cache;\n  };\n\n  return cache;\n}\n\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n\n  if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") {\n    return {\n      default: obj\n    };\n  }\n\n  var cache = _getRequireWildcardCache();\n\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n\n  newObj.default = obj;\n\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n\n  return newObj;\n}\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nvar _default = (0, _gensync().default)(function* loadFullConfig(inputOpts) {\n  const result = yield* (0, _partial.default)(inputOpts);\n\n  if (!result) {\n    return null;\n  }\n\n  const {\n    options,\n    context,\n    fileHandling\n  } = result;\n\n  if (fileHandling === \"ignored\") {\n    return null;\n  }\n\n  const optionDefaults = {};\n  const {\n    plugins,\n    presets\n  } = options;\n\n  if (!plugins || !presets) {\n    throw new Error(\"Assertion failure - plugins and presets exist\");\n  }\n\n  const toDescriptor = item => {\n    const desc = (0, _item.getItemDescriptor)(item);\n\n    if (!desc) {\n      throw new Error(\"Assertion failure - must be config item\");\n    }\n\n    return desc;\n  };\n\n  const presetsDescriptors = presets.map(toDescriptor);\n  const initialPluginsDescriptors = plugins.map(toDescriptor);\n  const pluginDescriptorsByPass = [[]];\n  const passes = [];\n  const ignored = yield* enhanceError(context, function* recursePresetDescriptors(rawPresets, pluginDescriptorsPass) {\n    const presets = [];\n\n    for (let i = 0; i < rawPresets.length; i++) {\n      const descriptor = rawPresets[i];\n\n      if (descriptor.options !== false) {\n        try {\n          if (descriptor.ownPass) {\n            presets.push({\n              preset: yield* loadPresetDescriptor(descriptor, context),\n              pass: []\n            });\n          } else {\n            presets.unshift({\n              preset: yield* loadPresetDescriptor(descriptor, context),\n              pass: pluginDescriptorsPass\n            });\n          }\n        } catch (e) {\n          if (e.code === \"BABEL_UNKNOWN_OPTION\") {\n            (0, _options.checkNoUnwrappedItemOptionPairs)(rawPresets, i, \"preset\", e);\n          }\n\n          throw e;\n        }\n      }\n    }\n\n    if (presets.length > 0) {\n      pluginDescriptorsByPass.splice(1, 0, ...presets.map(o => o.pass).filter(p => p !== pluginDescriptorsPass));\n\n      for (const {\n        preset,\n        pass\n      } of presets) {\n        if (!preset) return true;\n        pass.push(...preset.plugins);\n        const ignored = yield* recursePresetDescriptors(preset.presets, pass);\n        if (ignored) return true;\n        preset.options.forEach(opts => {\n          (0, _util.mergeOptions)(optionDefaults, opts);\n        });\n      }\n    }\n  })(presetsDescriptors, pluginDescriptorsByPass[0]);\n  if (ignored) return null;\n  const opts = optionDefaults;\n  (0, _util.mergeOptions)(opts, options);\n  yield* enhanceError(context, function* loadPluginDescriptors() {\n    pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors);\n\n    for (const descs of pluginDescriptorsByPass) {\n      const pass = [];\n      passes.push(pass);\n\n      for (let i = 0; i < descs.length; i++) {\n        const descriptor = descs[i];\n\n        if (descriptor.options !== false) {\n          try {\n            pass.push(yield* loadPluginDescriptor(descriptor, context));\n          } catch (e) {\n            if (e.code === \"BABEL_UNKNOWN_PLUGIN_PROPERTY\") {\n              (0, _options.checkNoUnwrappedItemOptionPairs)(descs, i, \"plugin\", e);\n            }\n\n            throw e;\n          }\n        }\n      }\n    }\n  })();\n  opts.plugins = passes[0];\n  opts.presets = passes.slice(1).filter(plugins => plugins.length > 0).map(plugins => ({\n    plugins\n  }));\n  opts.passPerPreset = opts.presets.length > 0;\n  return {\n    options: opts,\n    passes: passes\n  };\n});\n\nexports.default = _default;\n\nfunction enhanceError(context, fn) {\n  return function* (arg1, arg2) {\n    try {\n      return yield* fn(arg1, arg2);\n    } catch (e) {\n      if (!/^\\[BABEL\\]/.test(e.message)) {\n        e.message = `[BABEL] ${context.filename || \"unknown\"}: ${e.message}`;\n      }\n\n      throw e;\n    }\n  };\n}\n\nconst loadDescriptor = (0, _caching.makeWeakCache)(function* ({\n  value,\n  options,\n  dirname,\n  alias\n}, cache) {\n  if (options === false) throw new Error(\"Assertion failure\");\n  options = options || {};\n  let item = value;\n\n  if (typeof value === \"function\") {\n    const api = Object.assign({}, context, (0, _configApi.default)(cache));\n\n    try {\n      item = value(api, options, dirname);\n    } catch (e) {\n      if (alias) {\n        e.message += ` (While processing: ${JSON.stringify(alias)})`;\n      }\n\n      throw e;\n    }\n  }\n\n  if (!item || typeof item !== \"object\") {\n    throw new Error(\"Plugin/Preset did not return an object.\");\n  }\n\n  if (typeof item.then === \"function\") {\n    yield* [];\n    throw new Error(`You appear to be using an async plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, ` + `you may need to upgrade your @babel/core version.`);\n  }\n\n  return {\n    value: item,\n    options,\n    dirname,\n    alias\n  };\n});\n\nfunction* loadPluginDescriptor(descriptor, context) {\n  if (descriptor.value instanceof _plugin.default) {\n    if (descriptor.options) {\n      throw new Error(\"Passed options to an existing Plugin instance will not work.\");\n    }\n\n    return descriptor.value;\n  }\n\n  return yield* instantiatePlugin(yield* loadDescriptor(descriptor, context), context);\n}\n\nconst instantiatePlugin = (0, _caching.makeWeakCache)(function* ({\n  value,\n  options,\n  dirname,\n  alias\n}, cache) {\n  const pluginObj = (0, _plugins.validatePluginObject)(value);\n  const plugin = Object.assign({}, pluginObj);\n\n  if (plugin.visitor) {\n    plugin.visitor = _traverse().default.explode(Object.assign({}, plugin.visitor));\n  }\n\n  if (plugin.inherits) {\n    const inheritsDescriptor = {\n      name: undefined,\n      alias: `${alias}$inherits`,\n      value: plugin.inherits,\n      options,\n      dirname\n    };\n    const inherits = yield* (0, _async.forwardAsync)(loadPluginDescriptor, run => {\n      return cache.invalidate(data => run(inheritsDescriptor, data));\n    });\n    plugin.pre = chain(inherits.pre, plugin.pre);\n    plugin.post = chain(inherits.post, plugin.post);\n    plugin.manipulateOptions = chain(inherits.manipulateOptions, plugin.manipulateOptions);\n    plugin.visitor = _traverse().default.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);\n  }\n\n  return new _plugin.default(plugin, options, alias);\n});\n\nconst validateIfOptionNeedsFilename = (options, descriptor) => {\n  if (options.test || options.include || options.exclude) {\n    const formattedPresetName = descriptor.name ? `\"${descriptor.name}\"` : \"/* your preset */\";\n    throw new Error([`Preset ${formattedPresetName} requires a filename to be set when babel is called directly,`, `\\`\\`\\``, `babel.transform(code, { filename: 'file.ts', presets: [${formattedPresetName}] });`, `\\`\\`\\``, `See https://babeljs.io/docs/en/options#filename for more information.`].join(\"\\n\"));\n  }\n};\n\nconst validatePreset = (preset, context, descriptor) => {\n  if (!context.filename) {\n    const {\n      options\n    } = preset;\n    validateIfOptionNeedsFilename(options, descriptor);\n\n    if (options.overrides) {\n      options.overrides.forEach(overrideOptions => validateIfOptionNeedsFilename(overrideOptions, descriptor));\n    }\n  }\n};\n\nfunction* loadPresetDescriptor(descriptor, context) {\n  const preset = instantiatePreset(yield* loadDescriptor(descriptor, context));\n  validatePreset(preset, context, descriptor);\n  return yield* (0, _configChain.buildPresetChain)(preset, context);\n}\n\nconst instantiatePreset = (0, _caching.makeWeakCacheSync)(({\n  value,\n  dirname,\n  alias\n}) => {\n  return {\n    options: (0, _options.validate)(\"preset\", value),\n    alias,\n    dirname\n  };\n});\n\nfunction chain(a, b) {\n  const fns = [a, b].filter(Boolean);\n  if (fns.length <= 1) return fns[0];\n  return function (...args) {\n    for (const fn of fns) {\n      fn.apply(this, args);\n    }\n  };\n}","map":{"version":3,"sources":["/Users/alperenalkan/obss/frontend/frontend/node_modules/@babel/core/lib/config/full.js"],"names":["Object","defineProperty","exports","value","default","_gensync","data","_interopRequireDefault","require","_async","_util","context","_interopRequireWildcard","_plugin","_item","_configChain","_traverse","_caching","_options","_plugins","_configApi","_partial","_getRequireWildcardCache","WeakMap","cache","obj","__esModule","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_default","loadFullConfig","inputOpts","result","options","fileHandling","optionDefaults","plugins","presets","Error","toDescriptor","item","getItemDescriptor","presetsDescriptors","map","initialPluginsDescriptors","pluginDescriptorsByPass","passes","ignored","enhanceError","recursePresetDescriptors","rawPresets","pluginDescriptorsPass","i","length","descriptor","ownPass","push","preset","loadPresetDescriptor","pass","unshift","e","code","checkNoUnwrappedItemOptionPairs","splice","o","filter","p","forEach","opts","mergeOptions","loadPluginDescriptors","descs","loadPluginDescriptor","slice","passPerPreset","fn","arg1","arg2","test","message","filename","loadDescriptor","makeWeakCache","dirname","alias","api","assign","JSON","stringify","then","instantiatePlugin","pluginObj","validatePluginObject","plugin","visitor","explode","inherits","inheritsDescriptor","name","undefined","forwardAsync","run","invalidate","pre","chain","post","manipulateOptions","visitors","merge","validateIfOptionNeedsFilename","include","exclude","formattedPresetName","join","validatePreset","overrides","overrideOptions","instantiatePreset","buildPresetChain","makeWeakCacheSync","validate","a","b","fns","Boolean","args","apply"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _gensync() {\n  const data = _interopRequireDefault(require(\"gensync\"));\n\n  _gensync = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _async = require(\"../gensync-utils/async\");\n\nvar _util = require(\"./util\");\n\nvar context = _interopRequireWildcard(require(\"../index\"));\n\nvar _plugin = _interopRequireDefault(require(\"./plugin\"));\n\nvar _item = require(\"./item\");\n\nvar _configChain = require(\"./config-chain\");\n\nfunction _traverse() {\n  const data = _interopRequireDefault(require(\"@babel/traverse\"));\n\n  _traverse = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _caching = require(\"./caching\");\n\nvar _options = require(\"./validation/options\");\n\nvar _plugins = require(\"./validation/plugins\");\n\nvar _configApi = _interopRequireDefault(require(\"./helpers/config-api\"));\n\nvar _partial = _interopRequireDefault(require(\"./partial\"));\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _default = (0, _gensync().default)(function* loadFullConfig(inputOpts) {\n  const result = yield* (0, _partial.default)(inputOpts);\n\n  if (!result) {\n    return null;\n  }\n\n  const {\n    options,\n    context,\n    fileHandling\n  } = result;\n\n  if (fileHandling === \"ignored\") {\n    return null;\n  }\n\n  const optionDefaults = {};\n  const {\n    plugins,\n    presets\n  } = options;\n\n  if (!plugins || !presets) {\n    throw new Error(\"Assertion failure - plugins and presets exist\");\n  }\n\n  const toDescriptor = item => {\n    const desc = (0, _item.getItemDescriptor)(item);\n\n    if (!desc) {\n      throw new Error(\"Assertion failure - must be config item\");\n    }\n\n    return desc;\n  };\n\n  const presetsDescriptors = presets.map(toDescriptor);\n  const initialPluginsDescriptors = plugins.map(toDescriptor);\n  const pluginDescriptorsByPass = [[]];\n  const passes = [];\n  const ignored = yield* enhanceError(context, function* recursePresetDescriptors(rawPresets, pluginDescriptorsPass) {\n    const presets = [];\n\n    for (let i = 0; i < rawPresets.length; i++) {\n      const descriptor = rawPresets[i];\n\n      if (descriptor.options !== false) {\n        try {\n          if (descriptor.ownPass) {\n            presets.push({\n              preset: yield* loadPresetDescriptor(descriptor, context),\n              pass: []\n            });\n          } else {\n            presets.unshift({\n              preset: yield* loadPresetDescriptor(descriptor, context),\n              pass: pluginDescriptorsPass\n            });\n          }\n        } catch (e) {\n          if (e.code === \"BABEL_UNKNOWN_OPTION\") {\n            (0, _options.checkNoUnwrappedItemOptionPairs)(rawPresets, i, \"preset\", e);\n          }\n\n          throw e;\n        }\n      }\n    }\n\n    if (presets.length > 0) {\n      pluginDescriptorsByPass.splice(1, 0, ...presets.map(o => o.pass).filter(p => p !== pluginDescriptorsPass));\n\n      for (const {\n        preset,\n        pass\n      } of presets) {\n        if (!preset) return true;\n        pass.push(...preset.plugins);\n        const ignored = yield* recursePresetDescriptors(preset.presets, pass);\n        if (ignored) return true;\n        preset.options.forEach(opts => {\n          (0, _util.mergeOptions)(optionDefaults, opts);\n        });\n      }\n    }\n  })(presetsDescriptors, pluginDescriptorsByPass[0]);\n  if (ignored) return null;\n  const opts = optionDefaults;\n  (0, _util.mergeOptions)(opts, options);\n  yield* enhanceError(context, function* loadPluginDescriptors() {\n    pluginDescriptorsByPass[0].unshift(...initialPluginsDescriptors);\n\n    for (const descs of pluginDescriptorsByPass) {\n      const pass = [];\n      passes.push(pass);\n\n      for (let i = 0; i < descs.length; i++) {\n        const descriptor = descs[i];\n\n        if (descriptor.options !== false) {\n          try {\n            pass.push(yield* loadPluginDescriptor(descriptor, context));\n          } catch (e) {\n            if (e.code === \"BABEL_UNKNOWN_PLUGIN_PROPERTY\") {\n              (0, _options.checkNoUnwrappedItemOptionPairs)(descs, i, \"plugin\", e);\n            }\n\n            throw e;\n          }\n        }\n      }\n    }\n  })();\n  opts.plugins = passes[0];\n  opts.presets = passes.slice(1).filter(plugins => plugins.length > 0).map(plugins => ({\n    plugins\n  }));\n  opts.passPerPreset = opts.presets.length > 0;\n  return {\n    options: opts,\n    passes: passes\n  };\n});\n\nexports.default = _default;\n\nfunction enhanceError(context, fn) {\n  return function* (arg1, arg2) {\n    try {\n      return yield* fn(arg1, arg2);\n    } catch (e) {\n      if (!/^\\[BABEL\\]/.test(e.message)) {\n        e.message = `[BABEL] ${context.filename || \"unknown\"}: ${e.message}`;\n      }\n\n      throw e;\n    }\n  };\n}\n\nconst loadDescriptor = (0, _caching.makeWeakCache)(function* ({\n  value,\n  options,\n  dirname,\n  alias\n}, cache) {\n  if (options === false) throw new Error(\"Assertion failure\");\n  options = options || {};\n  let item = value;\n\n  if (typeof value === \"function\") {\n    const api = Object.assign({}, context, (0, _configApi.default)(cache));\n\n    try {\n      item = value(api, options, dirname);\n    } catch (e) {\n      if (alias) {\n        e.message += ` (While processing: ${JSON.stringify(alias)})`;\n      }\n\n      throw e;\n    }\n  }\n\n  if (!item || typeof item !== \"object\") {\n    throw new Error(\"Plugin/Preset did not return an object.\");\n  }\n\n  if (typeof item.then === \"function\") {\n    yield* [];\n    throw new Error(`You appear to be using an async plugin, ` + `which your current version of Babel does not support. ` + `If you're using a published plugin, ` + `you may need to upgrade your @babel/core version.`);\n  }\n\n  return {\n    value: item,\n    options,\n    dirname,\n    alias\n  };\n});\n\nfunction* loadPluginDescriptor(descriptor, context) {\n  if (descriptor.value instanceof _plugin.default) {\n    if (descriptor.options) {\n      throw new Error(\"Passed options to an existing Plugin instance will not work.\");\n    }\n\n    return descriptor.value;\n  }\n\n  return yield* instantiatePlugin(yield* loadDescriptor(descriptor, context), context);\n}\n\nconst instantiatePlugin = (0, _caching.makeWeakCache)(function* ({\n  value,\n  options,\n  dirname,\n  alias\n}, cache) {\n  const pluginObj = (0, _plugins.validatePluginObject)(value);\n  const plugin = Object.assign({}, pluginObj);\n\n  if (plugin.visitor) {\n    plugin.visitor = _traverse().default.explode(Object.assign({}, plugin.visitor));\n  }\n\n  if (plugin.inherits) {\n    const inheritsDescriptor = {\n      name: undefined,\n      alias: `${alias}$inherits`,\n      value: plugin.inherits,\n      options,\n      dirname\n    };\n    const inherits = yield* (0, _async.forwardAsync)(loadPluginDescriptor, run => {\n      return cache.invalidate(data => run(inheritsDescriptor, data));\n    });\n    plugin.pre = chain(inherits.pre, plugin.pre);\n    plugin.post = chain(inherits.post, plugin.post);\n    plugin.manipulateOptions = chain(inherits.manipulateOptions, plugin.manipulateOptions);\n    plugin.visitor = _traverse().default.visitors.merge([inherits.visitor || {}, plugin.visitor || {}]);\n  }\n\n  return new _plugin.default(plugin, options, alias);\n});\n\nconst validateIfOptionNeedsFilename = (options, descriptor) => {\n  if (options.test || options.include || options.exclude) {\n    const formattedPresetName = descriptor.name ? `\"${descriptor.name}\"` : \"/* your preset */\";\n    throw new Error([`Preset ${formattedPresetName} requires a filename to be set when babel is called directly,`, `\\`\\`\\``, `babel.transform(code, { filename: 'file.ts', presets: [${formattedPresetName}] });`, `\\`\\`\\``, `See https://babeljs.io/docs/en/options#filename for more information.`].join(\"\\n\"));\n  }\n};\n\nconst validatePreset = (preset, context, descriptor) => {\n  if (!context.filename) {\n    const {\n      options\n    } = preset;\n    validateIfOptionNeedsFilename(options, descriptor);\n\n    if (options.overrides) {\n      options.overrides.forEach(overrideOptions => validateIfOptionNeedsFilename(overrideOptions, descriptor));\n    }\n  }\n};\n\nfunction* loadPresetDescriptor(descriptor, context) {\n  const preset = instantiatePreset(yield* loadDescriptor(descriptor, context));\n  validatePreset(preset, context, descriptor);\n  return yield* (0, _configChain.buildPresetChain)(preset, context);\n}\n\nconst instantiatePreset = (0, _caching.makeWeakCacheSync)(({\n  value,\n  dirname,\n  alias\n}) => {\n  return {\n    options: (0, _options.validate)(\"preset\", value),\n    alias,\n    dirname\n  };\n});\n\nfunction chain(a, b) {\n  const fns = [a, b].filter(Boolean);\n  if (fns.length <= 1) return fns[0];\n  return function (...args) {\n    for (const fn of fns) {\n      fn.apply(this, args);\n    }\n  };\n}"]},"metadata":{},"sourceType":"script"}