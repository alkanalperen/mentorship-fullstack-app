{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar t = require(\"@babel/types\");\n\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {\n      if (t.isJSXIdentifier(node, opts)) {\n        if (t.react.isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return t.isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return t.isMemberExpression(node) && t.isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (t.isStatement(node)) {\n      if (t.isVariableDeclaration(node)) {\n        if (t.isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (t.isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t.isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return t.isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return t.isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return t.isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return t.isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (t.isFlow(node)) {\n      return true;\n    } else if (t.isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t.isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (t.isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","map":{"version":3,"sources":["/Users/alperenalkan/obss/frontend/frontend/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"],"names":["Object","defineProperty","exports","value","ForAwaitStatement","NumericLiteralTypeAnnotation","ExistentialTypeParam","SpreadProperty","RestProperty","Flow","Pure","Generated","User","Var","BlockScoped","Referenced","Scope","Expression","Statement","BindingIdentifier","ReferencedMemberExpression","ReferencedIdentifier","t","require","types","checkPath","path","opts","node","parent","isIdentifier","isJSXMemberExpression","isJSXIdentifier","react","isCompatTag","name","isReferenced","parentPath","isMemberExpression","grandparent","isBinding","isStatement","isVariableDeclaration","isForXStatement","left","isForStatement","init","isReferencedIdentifier","isExpression","isScope","isBlockScoped","isVar","loc","isUser","scope","isPure","isFlow","isImportDeclaration","importKind","isExportDeclaration","exportKind","isImportSpecifier","isObjectPattern","isObjectExpression","await"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForAwaitStatement = exports.NumericLiteralTypeAnnotation = exports.ExistentialTypeParam = exports.SpreadProperty = exports.RestProperty = exports.Flow = exports.Pure = exports.Generated = exports.User = exports.Var = exports.BlockScoped = exports.Referenced = exports.Scope = exports.Expression = exports.Statement = exports.BindingIdentifier = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = void 0;\n\nvar t = require(\"@babel/types\");\n\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!t.isIdentifier(node, opts) && !t.isJSXMemberExpression(parent, opts)) {\n      if (t.isJSXIdentifier(node, opts)) {\n        if (t.react.isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return t.isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return t.isMemberExpression(node) && t.isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return t.isIdentifier(node) && t.isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (t.isStatement(node)) {\n      if (t.isVariableDeclaration(node)) {\n        if (t.isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (t.isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return t.isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return t.isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return t.isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return t.isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return t.isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (t.isFlow(node)) {\n      return true;\n    } else if (t.isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (t.isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (t.isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;"]},"metadata":{},"sourceType":"script"}