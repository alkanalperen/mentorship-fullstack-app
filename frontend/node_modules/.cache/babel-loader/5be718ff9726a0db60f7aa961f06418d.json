{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar t = require(\"@babel/types\");\n\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = t.variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = t.jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(t.cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;","map":{"version":3,"sources":["/Users/alperenalkan/obss/frontend/frontend/node_modules/@babel/traverse/lib/path/lib/hoister.js"],"names":["Object","defineProperty","exports","value","default","t","require","referenceVisitor","ReferencedIdentifier","path","state","isJSXIdentifier","react","isCompatTag","node","name","parentPath","isJSXMemberExpression","scope","isFunction","isArrowFunctionExpression","parent","breakOnScopePaths","push","binding","getBinding","violation","constantViolations","mutableBinding","stop","bindings","PathHoister","constructor","scopes","attachAfter","isCompatibleScope","key","keys","bindingIdentifierEquals","identifier","getCompatibleScopes","indexOf","getAttachmentPath","_getAttachmentPath","targetScope","isProgram","hasOwnBinding","kind","parentKey","bindingParentPath","getAttachmentParentForPath","violationPath","pop","hasOwnParamBindings","bodies","get","i","length","_blockHoist","getNextScopeAttachmentParent","Array","isArray","container","isStatement","constant","run","traverse","attachTo","getFunctionParent","uid","generateUidIdentifier","declarator","variableDeclarator","insertFn","attached","isVariableDeclarator","variableDeclaration","isJSXElement","children","jsxExpressionContainer","replaceWith","cloneNode"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar t = require(\"@babel/types\");\n\nconst referenceVisitor = {\n  ReferencedIdentifier(path, state) {\n    if (path.isJSXIdentifier() && t.react.isCompatTag(path.node.name) && !path.parentPath.isJSXMemberExpression()) {\n      return;\n    }\n\n    if (path.node.name === \"this\") {\n      let scope = path.scope;\n\n      do {\n        if (scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n          break;\n        }\n      } while (scope = scope.parent);\n\n      if (scope) state.breakOnScopePaths.push(scope.path);\n    }\n\n    const binding = path.scope.getBinding(path.node.name);\n    if (!binding) return;\n\n    for (const violation of binding.constantViolations) {\n      if (violation.scope !== binding.path.scope) {\n        state.mutableBinding = true;\n        path.stop();\n        return;\n      }\n    }\n\n    if (binding !== state.scope.getBinding(path.node.name)) return;\n    state.bindings[path.node.name] = binding;\n  }\n\n};\n\nclass PathHoister {\n  constructor(path, scope) {\n    this.breakOnScopePaths = void 0;\n    this.bindings = void 0;\n    this.mutableBinding = void 0;\n    this.scopes = void 0;\n    this.scope = void 0;\n    this.path = void 0;\n    this.attachAfter = void 0;\n    this.breakOnScopePaths = [];\n    this.bindings = {};\n    this.mutableBinding = false;\n    this.scopes = [];\n    this.scope = scope;\n    this.path = path;\n    this.attachAfter = false;\n  }\n\n  isCompatibleScope(scope) {\n    for (const key of Object.keys(this.bindings)) {\n      const binding = this.bindings[key];\n\n      if (!scope.bindingIdentifierEquals(key, binding.identifier)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  getCompatibleScopes() {\n    let scope = this.path.scope;\n\n    do {\n      if (this.isCompatibleScope(scope)) {\n        this.scopes.push(scope);\n      } else {\n        break;\n      }\n\n      if (this.breakOnScopePaths.indexOf(scope.path) >= 0) {\n        break;\n      }\n    } while (scope = scope.parent);\n  }\n\n  getAttachmentPath() {\n    let path = this._getAttachmentPath();\n\n    if (!path) return;\n    let targetScope = path.scope;\n\n    if (targetScope.path === path) {\n      targetScope = path.scope.parent;\n    }\n\n    if (targetScope.path.isProgram() || targetScope.path.isFunction()) {\n      for (const name of Object.keys(this.bindings)) {\n        if (!targetScope.hasOwnBinding(name)) continue;\n        const binding = this.bindings[name];\n\n        if (binding.kind === \"param\" || binding.path.parentKey === \"params\") {\n          continue;\n        }\n\n        const bindingParentPath = this.getAttachmentParentForPath(binding.path);\n\n        if (bindingParentPath.key >= path.key) {\n          this.attachAfter = true;\n          path = binding.path;\n\n          for (const violationPath of binding.constantViolations) {\n            if (this.getAttachmentParentForPath(violationPath).key > path.key) {\n              path = violationPath;\n            }\n          }\n        }\n      }\n    }\n\n    return path;\n  }\n\n  _getAttachmentPath() {\n    const scopes = this.scopes;\n    const scope = scopes.pop();\n    if (!scope) return;\n\n    if (scope.path.isFunction()) {\n      if (this.hasOwnParamBindings(scope)) {\n        if (this.scope === scope) return;\n        const bodies = scope.path.get(\"body\").get(\"body\");\n\n        for (let i = 0; i < bodies.length; i++) {\n          if (bodies[i].node._blockHoist) continue;\n          return bodies[i];\n        }\n      } else {\n        return this.getNextScopeAttachmentParent();\n      }\n    } else if (scope.path.isProgram()) {\n      return this.getNextScopeAttachmentParent();\n    }\n  }\n\n  getNextScopeAttachmentParent() {\n    const scope = this.scopes.pop();\n    if (scope) return this.getAttachmentParentForPath(scope.path);\n  }\n\n  getAttachmentParentForPath(path) {\n    do {\n      if (!path.parentPath || Array.isArray(path.container) && path.isStatement()) {\n        return path;\n      }\n    } while (path = path.parentPath);\n  }\n\n  hasOwnParamBindings(scope) {\n    for (const name of Object.keys(this.bindings)) {\n      if (!scope.hasOwnBinding(name)) continue;\n      const binding = this.bindings[name];\n      if (binding.kind === \"param\" && binding.constant) return true;\n    }\n\n    return false;\n  }\n\n  run() {\n    this.path.traverse(referenceVisitor, this);\n    if (this.mutableBinding) return;\n    this.getCompatibleScopes();\n    const attachTo = this.getAttachmentPath();\n    if (!attachTo) return;\n    if (attachTo.getFunctionParent() === this.path.getFunctionParent()) return;\n    let uid = attachTo.scope.generateUidIdentifier(\"ref\");\n    const declarator = t.variableDeclarator(uid, this.path.node);\n    const insertFn = this.attachAfter ? \"insertAfter\" : \"insertBefore\";\n    const [attached] = attachTo[insertFn]([attachTo.isVariableDeclarator() ? declarator : t.variableDeclaration(\"var\", [declarator])]);\n    const parent = this.path.parentPath;\n\n    if (parent.isJSXElement() && this.path.container === parent.node.children) {\n      uid = t.jsxExpressionContainer(uid);\n    }\n\n    this.path.replaceWith(t.cloneNode(uid));\n    return attachTo.isVariableDeclarator() ? attached.get(\"init\") : attached.get(\"declarations.0.init\");\n  }\n\n}\n\nexports.default = PathHoister;"]},"metadata":{},"sourceType":"script"}