{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\n\nvar t = require('@babel/types');\n\nfunction _interopNamespace(e) {\n  if (e && e.__esModule) return e;\n  var n = Object.create(null);\n\n  if (e) {\n    Object.keys(e).forEach(function (k) {\n      if (k !== 'default') {\n        var d = Object.getOwnPropertyDescriptor(e, k);\n        Object.defineProperty(n, k, d.get ? d : {\n          enumerable: true,\n          get: function () {\n            return e[k];\n          }\n        });\n      }\n    });\n  }\n\n  n['default'] = e;\n  return Object.freeze(n);\n}\n\nvar t__namespace = /*#__PURE__*/_interopNamespace(t);\n\nfunction willPathCastToBoolean(path) {\n  const maybeWrapped = path;\n  const {\n    node,\n    parentPath\n  } = maybeWrapped;\n\n  if (parentPath.isLogicalExpression()) {\n    const {\n      operator,\n      right\n    } = parentPath.node;\n\n    if (operator === \"&&\" || operator === \"||\" || operator === \"??\" && node === right) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n\n  if (parentPath.isSequenceExpression()) {\n    const {\n      expressions\n    } = parentPath.node;\n\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      return true;\n    }\n  }\n\n  return parentPath.isConditional({\n    test: node\n  }) || parentPath.isUnaryExpression({\n    operator: \"!\"\n  }) || parentPath.isLoop({\n    test: node\n  });\n}\n\nclass AssignmentMemoiser {\n  constructor() {\n    this._map = void 0;\n    this._map = new WeakMap();\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  get(key) {\n    if (!this.has(key)) return;\n\n    const record = this._map.get(key);\n\n    const {\n      value\n    } = record;\n    record.count--;\n\n    if (record.count === 0) {\n      return t__namespace.assignmentExpression(\"=\", value, key);\n    }\n\n    return value;\n  }\n\n  set(key, value, count) {\n    return this._map.set(key, {\n      count,\n      value\n    });\n  }\n\n}\n\nfunction toNonOptional(path, base) {\n  const {\n    node\n  } = path;\n\n  if (path.isOptionalMemberExpression()) {\n    return t__namespace.memberExpression(base, node.property, node.computed);\n  }\n\n  if (path.isOptionalCallExpression()) {\n    const callee = path.get(\"callee\");\n\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\n      const {\n        object\n      } = callee.node;\n      const context = path.scope.maybeGenerateMemoised(object) || object;\n      callee.get(\"object\").replaceWith(t__namespace.assignmentExpression(\"=\", context, object));\n      return t__namespace.callExpression(t__namespace.memberExpression(base, t__namespace.identifier(\"call\")), [context, ...node.arguments]);\n    }\n\n    return t__namespace.callExpression(base, node.arguments);\n  }\n\n  return path.node;\n}\n\nfunction isInDetachedTree(path) {\n  while (path) {\n    if (path.isProgram()) break;\n    const {\n      parentPath,\n      container,\n      listKey\n    } = path;\n    const parentNode = parentPath.node;\n\n    if (listKey) {\n      if (container !== parentNode[listKey]) return true;\n    } else {\n      if (container !== parentNode) return true;\n    }\n\n    path = parentPath;\n  }\n\n  return false;\n}\n\nconst handle = {\n  memoise() {},\n\n  handle(member, noDocumentAll) {\n    const {\n      node,\n      parent,\n      parentPath,\n      scope\n    } = member;\n\n    if (member.isOptionalMemberExpression()) {\n      if (isInDetachedTree(member)) return;\n      const endPath = member.find(({\n        node,\n        parent,\n        parentPath\n      }) => {\n        if (parentPath.isOptionalMemberExpression()) {\n          return parent.optional || parent.object !== node;\n        }\n\n        if (parentPath.isOptionalCallExpression()) {\n          return node !== member.node && parent.optional || parent.callee !== node;\n        }\n\n        return true;\n      });\n\n      if (scope.path.isPattern()) {\n        endPath.replaceWith(t__namespace.callExpression(t__namespace.arrowFunctionExpression([], endPath.node), []));\n        return;\n      }\n\n      const willEndPathCastToBoolean = willPathCastToBoolean(endPath);\n      const rootParentPath = endPath.parentPath;\n\n      if (rootParentPath.isUpdateExpression({\n        argument: node\n      }) || rootParentPath.isAssignmentExpression({\n        left: node\n      })) {\n        throw member.buildCodeFrameError(`can't handle assignment`);\n      }\n\n      const isDeleteOperation = rootParentPath.isUnaryExpression({\n        operator: \"delete\"\n      });\n\n      if (isDeleteOperation && endPath.isOptionalMemberExpression() && endPath.get(\"property\").isPrivateName()) {\n        throw member.buildCodeFrameError(`can't delete a private class element`);\n      }\n\n      let startingOptional = member;\n\n      for (;;) {\n        if (startingOptional.isOptionalMemberExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"object\");\n          continue;\n        } else if (startingOptional.isOptionalCallExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"callee\");\n          continue;\n        }\n\n        throw new Error(`Internal error: unexpected ${startingOptional.node.type}`);\n      }\n\n      const startingProp = startingOptional.isOptionalMemberExpression() ? \"object\" : \"callee\";\n      const startingNode = startingOptional.node[startingProp];\n      const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\n      const baseRef = baseNeedsMemoised != null ? baseNeedsMemoised : startingNode;\n      const parentIsOptionalCall = parentPath.isOptionalCallExpression({\n        callee: node\n      });\n      const parentIsCall = parentPath.isCallExpression({\n        callee: node\n      });\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\n\n      if (parentIsOptionalCall) {\n        if (parent.optional) {\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n        } else {\n          parentPath.replaceWith(this.call(member, parent.arguments));\n        }\n      } else if (parentIsCall) {\n        member.replaceWith(this.boundGet(member));\n      } else {\n        member.replaceWith(this.get(member));\n      }\n\n      let regular = member.node;\n\n      for (let current = member; current !== endPath;) {\n        const {\n          parentPath\n        } = current;\n\n        if (parentPath === endPath && parentIsOptionalCall && parent.optional) {\n          regular = parentPath.node;\n          break;\n        }\n\n        regular = toNonOptional(parentPath, regular);\n        current = parentPath;\n      }\n\n      let context;\n      const endParentPath = endPath.parentPath;\n\n      if (t__namespace.isMemberExpression(regular) && endParentPath.isOptionalCallExpression({\n        callee: endPath.node,\n        optional: true\n      })) {\n        const {\n          object\n        } = regular;\n        context = member.scope.maybeGenerateMemoised(object);\n\n        if (context) {\n          regular.object = t__namespace.assignmentExpression(\"=\", context, object);\n        }\n      }\n\n      let replacementPath = endPath;\n\n      if (isDeleteOperation) {\n        replacementPath = endParentPath;\n        regular = endParentPath.node;\n      }\n\n      const baseMemoised = baseNeedsMemoised ? t__namespace.assignmentExpression(\"=\", t__namespace.cloneNode(baseRef), t__namespace.cloneNode(startingNode)) : t__namespace.cloneNode(baseRef);\n\n      if (willEndPathCastToBoolean) {\n        let nonNullishCheck;\n\n        if (noDocumentAll) {\n          nonNullishCheck = t__namespace.binaryExpression(\"!=\", baseMemoised, t__namespace.nullLiteral());\n        } else {\n          nonNullishCheck = t__namespace.logicalExpression(\"&&\", t__namespace.binaryExpression(\"!==\", baseMemoised, t__namespace.nullLiteral()), t__namespace.binaryExpression(\"!==\", t__namespace.cloneNode(baseRef), scope.buildUndefinedNode()));\n        }\n\n        replacementPath.replaceWith(t__namespace.logicalExpression(\"&&\", nonNullishCheck, regular));\n      } else {\n        let nullishCheck;\n\n        if (noDocumentAll) {\n          nullishCheck = t__namespace.binaryExpression(\"==\", baseMemoised, t__namespace.nullLiteral());\n        } else {\n          nullishCheck = t__namespace.logicalExpression(\"||\", t__namespace.binaryExpression(\"===\", baseMemoised, t__namespace.nullLiteral()), t__namespace.binaryExpression(\"===\", t__namespace.cloneNode(baseRef), scope.buildUndefinedNode()));\n        }\n\n        replacementPath.replaceWith(t__namespace.conditionalExpression(nullishCheck, isDeleteOperation ? t__namespace.booleanLiteral(true) : scope.buildUndefinedNode(), regular));\n      }\n\n      if (context) {\n        const endParent = endParentPath.node;\n        endParentPath.replaceWith(t__namespace.optionalCallExpression(t__namespace.optionalMemberExpression(endParent.callee, t__namespace.identifier(\"call\"), false, true), [t__namespace.cloneNode(context), ...endParent.arguments], false));\n      }\n\n      return;\n    }\n\n    if (parentPath.isUpdateExpression({\n      argument: node\n    })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const {\n        operator,\n        prefix\n      } = parent;\n      this.memoise(member, 2);\n      const value = t__namespace.binaryExpression(operator[0], t__namespace.unaryExpression(\"+\", this.get(member)), t__namespace.numericLiteral(1));\n\n      if (prefix) {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const {\n          scope\n        } = member;\n        const ref = scope.generateUidIdentifierBasedOnNode(node);\n        scope.push({\n          id: ref\n        });\n        value.left = t__namespace.assignmentExpression(\"=\", t__namespace.cloneNode(ref), value.left);\n        parentPath.replaceWith(t__namespace.sequenceExpression([this.set(member, value), t__namespace.cloneNode(ref)]));\n      }\n\n      return;\n    }\n\n    if (parentPath.isAssignmentExpression({\n      left: node\n    })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const {\n        operator,\n        right: value\n      } = parent;\n\n      if (operator === \"=\") {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const operatorTrunc = operator.slice(0, -1);\n\n        if (t__namespace.LOGICAL_OPERATORS.includes(operatorTrunc)) {\n          this.memoise(member, 1);\n          parentPath.replaceWith(t__namespace.logicalExpression(operatorTrunc, this.get(member), this.set(member, value)));\n        } else {\n          this.memoise(member, 2);\n          parentPath.replaceWith(this.set(member, t__namespace.binaryExpression(operatorTrunc, this.get(member), value)));\n        }\n      }\n\n      return;\n    }\n\n    if (parentPath.isCallExpression({\n      callee: node\n    })) {\n      parentPath.replaceWith(this.call(member, parent.arguments));\n      return;\n    }\n\n    if (parentPath.isOptionalCallExpression({\n      callee: node\n    })) {\n      if (scope.path.isPattern()) {\n        parentPath.replaceWith(t__namespace.callExpression(t__namespace.arrowFunctionExpression([], parentPath.node), []));\n        return;\n      }\n\n      parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n      return;\n    }\n\n    if (parentPath.isForXStatement({\n      left: node\n    }) || parentPath.isObjectProperty({\n      value: node\n    }) && parentPath.parentPath.isObjectPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isObjectProperty({\n      value: parent\n    }) && parentPath.parentPath.parentPath.isObjectPattern() || parentPath.isArrayPattern() || parentPath.isAssignmentPattern({\n      left: node\n    }) && parentPath.parentPath.isArrayPattern() || parentPath.isRestElement()) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    if (parentPath.isTaggedTemplateExpression()) {\n      member.replaceWith(this.boundGet(member));\n    } else {\n      member.replaceWith(this.get(member));\n    }\n  }\n\n};\n\nfunction memberExpressionToFunctions(path, visitor, state) {\n  path.traverse(visitor, Object.assign({}, handle, state, {\n    memoiser: new AssignmentMemoiser()\n  }));\n}\n\nexports.default = memberExpressionToFunctions;","map":{"version":3,"sources":["../src/util.ts","../src/index.ts"],"names":["maybeWrapped","parentPath","right","operator","node","willPathCastToBoolean","expressions","test","_map","constructor","has","get","record","value","t","set","path","callee","object","context","listKey","parentNode","container","handle","memoise","scope","member","isInDetachedTree","endPath","parent","willEndPathCastToBoolean","rootParentPath","argument","left","isDeleteOperation","startingOptional","type","startingProp","startingNode","baseNeedsMemoised","baseRef","parentIsOptionalCall","parentIsCall","toNonOptional","regular","current","endParentPath","optional","replacementPath","baseMemoised","nonNullishCheck","nullishCheck","endParent","prefix","ref","id","operatorTrunc","memoiser"],"mappings":"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","sourcesContent":["import type { NodePath } from \"@babel/traverse\";\n\n/**\n * Test if a NodePath will be cast to boolean when evaluated.\n *\n * @example\n * // returns true\n * const nodePathAQDotB = NodePath(\"if (a?.#b) {}\").get(\"test\"); // a?.#b\n * willPathCastToBoolean(nodePathAQDotB)\n * @example\n * // returns false\n * willPathCastToBoolean(NodePath(\"a?.#b\"))\n * @todo Respect transparent expression wrappers\n * @see {@link packages/babel-plugin-proposal-optional-chaining/src/util.js}\n * @param {NodePath} path\n * @returns {boolean}\n */\nexport function willPathCastToBoolean(path: NodePath): boolean {\n  const maybeWrapped = path;\n  const { node, parentPath } = maybeWrapped;\n  if (parentPath.isLogicalExpression()) {\n    const { operator, right } = parentPath.node;\n    if (\n      operator === \"&&\" ||\n      operator === \"||\" ||\n      (operator === \"??\" && node === right)\n    ) {\n      return willPathCastToBoolean(parentPath);\n    }\n  }\n  if (parentPath.isSequenceExpression()) {\n    const { expressions } = parentPath.node;\n    if (expressions[expressions.length - 1] === node) {\n      return willPathCastToBoolean(parentPath);\n    } else {\n      // if it is in the middle of a sequence expression, we don't\n      // care the return value so just cast to boolean for smaller\n      // output\n      return true;\n    }\n  }\n  return (\n    parentPath.isConditional({ test: node }) ||\n    parentPath.isUnaryExpression({ operator: \"!\" }) ||\n    parentPath.isLoop({ test: node })\n  );\n}\n","import * as t from \"@babel/types\";\nimport { willPathCastToBoolean } from \"./util\";\n\nclass AssignmentMemoiser {\n  private _map: WeakMap<object, any>;\n  constructor() {\n    this._map = new WeakMap();\n  }\n\n  has(key) {\n    return this._map.has(key);\n  }\n\n  get(key) {\n    if (!this.has(key)) return;\n\n    const record = this._map.get(key);\n    const { value } = record;\n\n    record.count--;\n    if (record.count === 0) {\n      // The `count` access is the outermost function call (hopefully), so it\n      // does the assignment.\n      return t.assignmentExpression(\"=\", value, key);\n    }\n    return value;\n  }\n\n  set(key, value, count) {\n    return this._map.set(key, { count, value });\n  }\n}\n\nfunction toNonOptional(path, base) {\n  const { node } = path;\n  if (path.isOptionalMemberExpression()) {\n    return t.memberExpression(base, node.property, node.computed);\n  }\n\n  if (path.isOptionalCallExpression()) {\n    const callee = path.get(\"callee\");\n    if (path.node.optional && callee.isOptionalMemberExpression()) {\n      const { object } = callee.node;\n      const context = path.scope.maybeGenerateMemoised(object) || object;\n      callee\n        .get(\"object\")\n        .replaceWith(t.assignmentExpression(\"=\", context, object));\n\n      return t.callExpression(t.memberExpression(base, t.identifier(\"call\")), [\n        context,\n        ...node.arguments,\n      ]);\n    }\n\n    return t.callExpression(base, node.arguments);\n  }\n\n  return path.node;\n}\n\n// Determines if the current path is in a detached tree. This can happen when\n// we are iterating on a path, and replace an ancestor with a new node. Babel\n// doesn't always stop traversing the old node tree, and that can cause\n// inconsistencies.\nfunction isInDetachedTree(path) {\n  while (path) {\n    if (path.isProgram()) break;\n\n    const { parentPath, container, listKey } = path;\n    const parentNode = parentPath.node;\n    if (listKey) {\n      if (container !== parentNode[listKey]) return true;\n    } else {\n      if (container !== parentNode) return true;\n    }\n\n    path = parentPath;\n  }\n\n  return false;\n}\n\nconst handle = {\n  memoise() {\n    // noop.\n  },\n\n  // todo(flow->ts) member:NodePath<t.Expression>, refactor function body to avoid too many typecasts\n  handle(member: any, noDocumentAll: boolean) {\n    const { node, parent, parentPath, scope } = member;\n\n    if (member.isOptionalMemberExpression()) {\n      // Transforming optional chaining requires we replace ancestors.\n      if (isInDetachedTree(member)) return;\n\n      // We're looking for the end of _this_ optional chain, which is actually\n      // the \"rightmost\" property access of the chain. This is because\n      // everything up to that property access is \"optional\".\n      //\n      // Let's take the case of `FOO?.BAR.baz?.qux`, with `FOO?.BAR` being our\n      // member. The \"end\" to most users would be `qux` property access.\n      // Everything up to it could be skipped if it `FOO` were nullish. But\n      // actually, we can consider the `baz` access to be the end. So we're\n      // looking for the nearest optional chain that is `optional: true`.\n      const endPath = member.find(({ node, parent, parentPath }) => {\n        if (parentPath.isOptionalMemberExpression()) {\n          // We need to check `parent.object` since we could be inside the\n          // computed expression of a `bad?.[FOO?.BAR]`. In this case, the\n          // endPath is the `FOO?.BAR` member itself.\n          return parent.optional || parent.object !== node;\n        }\n        if (parentPath.isOptionalCallExpression()) {\n          // Checking `parent.callee` since we could be in the arguments, eg\n          // `bad?.(FOO?.BAR)`.\n          // Also skip `FOO?.BAR` in `FOO?.BAR?.()` since we need to transform the optional call to ensure proper this\n          return (\n            // In FOO?.#BAR?.(), endPath points the optional call expression so we skip FOO?.#BAR\n            (node !== member.node && parent.optional) || parent.callee !== node\n          );\n        }\n        return true;\n      });\n\n      // Replace `function (a, x = a.b?.#c) {}` to `function (a, x = (() => a.b?.#c)() ){}`\n      // so the temporary variable can be injected in correct scope\n      // This can be further optimized to avoid unecessary IIFE\n      if (scope.path.isPattern()) {\n        endPath.replaceWith(\n          // The injected member will be queued and eventually transformed when visited\n          t.callExpression(t.arrowFunctionExpression([], endPath.node), []),\n        );\n        return;\n      }\n\n      const willEndPathCastToBoolean = willPathCastToBoolean(endPath);\n\n      const rootParentPath = endPath.parentPath;\n      if (\n        rootParentPath.isUpdateExpression({ argument: node }) ||\n        rootParentPath.isAssignmentExpression({ left: node })\n      ) {\n        throw member.buildCodeFrameError(`can't handle assignment`);\n      }\n      const isDeleteOperation = rootParentPath.isUnaryExpression({\n        operator: \"delete\",\n      });\n      if (\n        isDeleteOperation &&\n        endPath.isOptionalMemberExpression() &&\n        endPath.get(\"property\").isPrivateName()\n      ) {\n        // @babel/parser will throw error on `delete obj?.#x`.\n        // This error serves as fallback when `delete obj?.#x` is constructed from babel types\n        throw member.buildCodeFrameError(\n          `can't delete a private class element`,\n        );\n      }\n\n      // Now, we're looking for the start of this optional chain, which is\n      // optional to the left of this member.\n      //\n      // Let's take the case of `foo?.bar?.baz.QUX?.BAM`, with `QUX?.BAM` being\n      // our member. The \"start\" to most users would be `foo` object access.\n      // But actually, we can consider the `bar` access to be the start. So\n      // we're looking for the nearest optional chain that is `optional: true`,\n      // which is guaranteed to be somewhere in the object/callee tree.\n      let startingOptional = member;\n      for (;;) {\n        if (startingOptional.isOptionalMemberExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"object\");\n          continue;\n        } else if (startingOptional.isOptionalCallExpression()) {\n          if (startingOptional.node.optional) break;\n          startingOptional = startingOptional.get(\"callee\");\n          continue;\n        }\n        // prevent infinite loop: unreachable if the AST is well-formed\n        throw new Error(\n          `Internal error: unexpected ${startingOptional.node.type}`,\n        );\n      }\n\n      const startingProp = startingOptional.isOptionalMemberExpression()\n        ? \"object\"\n        : \"callee\";\n      const startingNode = startingOptional.node[startingProp];\n      const baseNeedsMemoised = scope.maybeGenerateMemoised(startingNode);\n      const baseRef = baseNeedsMemoised ?? startingNode;\n\n      // Compute parentIsOptionalCall before `startingOptional` is replaced\n      // as `node` may refer to `startingOptional.node` before replaced.\n      const parentIsOptionalCall = parentPath.isOptionalCallExpression({\n        callee: node,\n      });\n      // if parentIsCall is true, it implies that node.extra.parenthesized is always true\n      const parentIsCall = parentPath.isCallExpression({ callee: node });\n      startingOptional.replaceWith(toNonOptional(startingOptional, baseRef));\n      if (parentIsOptionalCall) {\n        if (parent.optional) {\n          parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n        } else {\n          parentPath.replaceWith(this.call(member, parent.arguments));\n        }\n      } else if (parentIsCall) {\n        // `(a?.#b)()` to `(a == null ? void 0 : a.#b.bind(a))()`\n        member.replaceWith(this.boundGet(member));\n      } else {\n        member.replaceWith(this.get(member));\n      }\n\n      let regular = member.node;\n      for (let current = member; current !== endPath; ) {\n        const { parentPath } = current;\n        // skip transforming `Foo.#BAR?.call(FOO)`\n        if (parentPath === endPath && parentIsOptionalCall && parent.optional) {\n          regular = parentPath.node;\n          break;\n        }\n        regular = toNonOptional(parentPath, regular);\n        current = parentPath;\n      }\n\n      let context;\n      const endParentPath = endPath.parentPath;\n      if (\n        t.isMemberExpression(regular) &&\n        endParentPath.isOptionalCallExpression({\n          callee: endPath.node,\n          optional: true,\n        })\n      ) {\n        const { object } = regular;\n        context = member.scope.maybeGenerateMemoised(object);\n        if (context) {\n          regular.object = t.assignmentExpression(\"=\", context, object);\n        }\n      }\n\n      let replacementPath = endPath;\n      if (isDeleteOperation) {\n        replacementPath = endParentPath;\n        regular = endParentPath.node;\n      }\n\n      const baseMemoised = baseNeedsMemoised\n        ? t.assignmentExpression(\n            \"=\",\n            t.cloneNode(baseRef),\n            t.cloneNode(startingNode),\n          )\n        : t.cloneNode(baseRef);\n\n      if (willEndPathCastToBoolean) {\n        let nonNullishCheck;\n        if (noDocumentAll) {\n          nonNullishCheck = t.binaryExpression(\n            \"!=\",\n            baseMemoised,\n            t.nullLiteral(),\n          );\n        } else {\n          nonNullishCheck = t.logicalExpression(\n            \"&&\",\n            t.binaryExpression(\"!==\", baseMemoised, t.nullLiteral()),\n            t.binaryExpression(\n              \"!==\",\n              t.cloneNode(baseRef),\n              scope.buildUndefinedNode(),\n            ),\n          );\n        }\n        replacementPath.replaceWith(\n          t.logicalExpression(\"&&\", nonNullishCheck, regular),\n        );\n      } else {\n        let nullishCheck;\n        if (noDocumentAll) {\n          nullishCheck = t.binaryExpression(\n            \"==\",\n            baseMemoised,\n            t.nullLiteral(),\n          );\n        } else {\n          nullishCheck = t.logicalExpression(\n            \"||\",\n            t.binaryExpression(\"===\", baseMemoised, t.nullLiteral()),\n            t.binaryExpression(\n              \"===\",\n              t.cloneNode(baseRef),\n              scope.buildUndefinedNode(),\n            ),\n          );\n        }\n\n        replacementPath.replaceWith(\n          t.conditionalExpression(\n            nullishCheck,\n            isDeleteOperation\n              ? t.booleanLiteral(true)\n              : scope.buildUndefinedNode(),\n            regular,\n          ),\n        );\n      }\n\n      // context and isDeleteOperation can not be both truthy\n      if (context) {\n        const endParent = endParentPath.node;\n        endParentPath.replaceWith(\n          t.optionalCallExpression(\n            t.optionalMemberExpression(\n              endParent.callee,\n              t.identifier(\"call\"),\n              false,\n              true,\n            ),\n            [t.cloneNode(context), ...endParent.arguments],\n            false,\n          ),\n        );\n      }\n\n      return;\n    }\n\n    // MEMBER++   ->   _set(MEMBER, (_ref = (+_get(MEMBER))) + 1), _ref\n    // ++MEMBER   ->   _set(MEMBER, (+_get(MEMBER)) + 1)\n    if (parentPath.isUpdateExpression({ argument: node })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const { operator, prefix } = parent;\n\n      // Give the state handler a chance to memoise the member, since we'll\n      // reference it twice. The second access (the set) should do the memo\n      // assignment.\n      this.memoise(member, 2);\n\n      const value = t.binaryExpression(\n        operator[0],\n        t.unaryExpression(\"+\", this.get(member)),\n        t.numericLiteral(1),\n      );\n\n      if (prefix) {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const { scope } = member;\n        const ref = scope.generateUidIdentifierBasedOnNode(node);\n        scope.push({ id: ref });\n\n        value.left = t.assignmentExpression(\n          \"=\",\n          t.cloneNode(ref),\n          // @ts-expect-error todo(flow->ts) value.left is possibly PrivateName, which is not usable here\n          value.left,\n        );\n\n        parentPath.replaceWith(\n          t.sequenceExpression([this.set(member, value), t.cloneNode(ref)]),\n        );\n      }\n      return;\n    }\n\n    // MEMBER = VALUE   ->   _set(MEMBER, VALUE)\n    // MEMBER += VALUE   ->   _set(MEMBER, _get(MEMBER) + VALUE)\n    // MEMBER ??= VALUE   ->   _get(MEMBER) ?? _set(MEMBER, VALUE)\n    if (parentPath.isAssignmentExpression({ left: node })) {\n      if (this.simpleSet) {\n        member.replaceWith(this.simpleSet(member));\n        return;\n      }\n\n      const { operator, right: value } = parent;\n\n      if (operator === \"=\") {\n        parentPath.replaceWith(this.set(member, value));\n      } else {\n        const operatorTrunc = operator.slice(0, -1);\n        if (t.LOGICAL_OPERATORS.includes(operatorTrunc)) {\n          // Give the state handler a chance to memoise the member, since we'll\n          // reference it twice. The first access (the get) should do the memo\n          // assignment.\n          this.memoise(member, 1);\n          parentPath.replaceWith(\n            t.logicalExpression(\n              operatorTrunc,\n              this.get(member),\n              this.set(member, value),\n            ),\n          );\n        } else {\n          // Here, the second access (the set) is evaluated first.\n          this.memoise(member, 2);\n          parentPath.replaceWith(\n            this.set(\n              member,\n              t.binaryExpression(operatorTrunc, this.get(member), value),\n            ),\n          );\n        }\n      }\n      return;\n    }\n\n    // MEMBER(ARGS) -> _call(MEMBER, ARGS)\n    if (parentPath.isCallExpression({ callee: node })) {\n      parentPath.replaceWith(this.call(member, parent.arguments));\n      return;\n    }\n\n    // MEMBER?.(ARGS) -> _optionalCall(MEMBER, ARGS)\n    if (parentPath.isOptionalCallExpression({ callee: node })) {\n      // Replace `function (a, x = a.b.#c?.()) {}` to `function (a, x = (() => a.b.#c?.())() ){}`\n      // so the temporary variable can be injected in correct scope\n      // This can be further optimized to avoid unecessary IIFE\n      if (scope.path.isPattern()) {\n        parentPath.replaceWith(\n          // The injected member will be queued and eventually transformed when visited\n          t.callExpression(t.arrowFunctionExpression([], parentPath.node), []),\n        );\n        return;\n      }\n      parentPath.replaceWith(this.optionalCall(member, parent.arguments));\n      return;\n    }\n\n    // for (MEMBER of ARR)\n    // for (MEMBER in ARR)\n    // { KEY: MEMBER } = OBJ -> { KEY: _destructureSet(MEMBER) } = OBJ\n    // { KEY: MEMBER = _VALUE } = OBJ -> { KEY: _destructureSet(MEMBER) = _VALUE } = OBJ\n    // {...MEMBER} -> {..._destructureSet(MEMBER)}\n    //\n    // [MEMBER] = ARR -> [_destructureSet(MEMBER)] = ARR\n    // [MEMBER = _VALUE] = ARR -> [_destructureSet(MEMBER) = _VALUE] = ARR\n    // [...MEMBER] -> [..._destructureSet(MEMBER)]\n    if (\n      // for (MEMBER of ARR)\n      // for (MEMBER in ARR)\n      parentPath.isForXStatement({ left: node }) ||\n      // { KEY: MEMBER } = OBJ\n      (parentPath.isObjectProperty({ value: node }) &&\n        parentPath.parentPath.isObjectPattern()) ||\n      // { KEY: MEMBER = _VALUE } = OBJ\n      (parentPath.isAssignmentPattern({ left: node }) &&\n        parentPath.parentPath.isObjectProperty({ value: parent }) &&\n        parentPath.parentPath.parentPath.isObjectPattern()) ||\n      // [MEMBER] = ARR\n      parentPath.isArrayPattern() ||\n      // [MEMBER = _VALUE] = ARR\n      (parentPath.isAssignmentPattern({ left: node }) &&\n        parentPath.parentPath.isArrayPattern()) ||\n      // {...MEMBER}\n      // [...MEMBER]\n      parentPath.isRestElement()\n    ) {\n      member.replaceWith(this.destructureSet(member));\n      return;\n    }\n\n    if (parentPath.isTaggedTemplateExpression()) {\n      // MEMBER   ->   _get(MEMBER).bind(this)\n      member.replaceWith(this.boundGet(member));\n    } else {\n      // MEMBER   ->   _get(MEMBER)\n      member.replaceWith(this.get(member));\n    }\n  },\n};\n\n// We do not provide a default traversal visitor\n// Instead, caller passes one, and must call `state.handle` on the members\n// it wishes to be transformed.\n// Additionally, the caller must pass in a state object with at least\n// get, set, and call methods.\n// Optionally, a memoise method may be defined on the state, which will be\n// called when the member is a self-referential update.\nexport default function memberExpressionToFunctions(path, visitor, state) {\n  path.traverse(visitor, {\n    ...handle,\n    ...state,\n    memoiser: new AssignmentMemoiser(),\n  });\n}\n"]},"metadata":{},"sourceType":"script"}