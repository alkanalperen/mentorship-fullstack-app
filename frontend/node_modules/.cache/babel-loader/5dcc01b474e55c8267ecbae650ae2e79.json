{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = require(\"../binding\");\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nvar t = require(\"@babel/types\");\n\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      skipAllButComputedMethodKey(path);\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = t.identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(t.identifier(this.newName), t.toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = t.identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: t.identifier(this.newName)\n    });\n    path.replaceWith(t.assignmentExpression(\"=\", t.identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;\n\nfunction skipAllButComputedMethodKey(path) {\n  if (!path.isMethod() || !path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = t.VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}","map":{"version":3,"sources":["/Users/alperenalkan/obss/frontend/frontend/node_modules/@babel/traverse/lib/scope/lib/renamer.js"],"names":["Object","defineProperty","exports","value","default","_binding","require","_helperSplitExportDeclaration","t","renameVisitor","ReferencedIdentifier","node","state","name","oldName","newName","Scope","path","scope","bindingIdentifierEquals","binding","identifier","skipAllButComputedMethodKey","isVariableDeclaration","ids","getOuterBindingIdentifiers","Renamer","constructor","maybeConvertFromExportDeclaration","parentDeclar","maybeExportDeclar","parentPath","isExportDeclaration","isExportDefaultDeclaration","get","id","maybeConvertFromClassFunctionDeclaration","isFunctionDeclaration","isClassDeclaration","kind","_blockHoist","replaceWith","variableDeclaration","variableDeclarator","toExpression","maybeConvertFromClassFunctionExpression","isFunctionExpression","isClassExpression","parent","push","assignmentExpression","rename","block","find","isDeclaration","bindingIds","blockToTraverse","type","cases","forEach","c","traverse","removeOwnBinding","bindings","isMethod","computed","skip","keys","VISITOR_KEYS","key","skipKey"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _binding = require(\"../binding\");\n\nvar _helperSplitExportDeclaration = require(\"@babel/helper-split-export-declaration\");\n\nvar t = require(\"@babel/types\");\n\nconst renameVisitor = {\n  ReferencedIdentifier({\n    node\n  }, state) {\n    if (node.name === state.oldName) {\n      node.name = state.newName;\n    }\n  },\n\n  Scope(path, state) {\n    if (!path.scope.bindingIdentifierEquals(state.oldName, state.binding.identifier)) {\n      skipAllButComputedMethodKey(path);\n    }\n  },\n\n  \"AssignmentExpression|Declaration|VariableDeclarator\"(path, state) {\n    if (path.isVariableDeclaration()) return;\n    const ids = path.getOuterBindingIdentifiers();\n\n    for (const name in ids) {\n      if (name === state.oldName) ids[name].name = state.newName;\n    }\n  }\n\n};\n\nclass Renamer {\n  constructor(binding, oldName, newName) {\n    this.newName = newName;\n    this.oldName = oldName;\n    this.binding = binding;\n  }\n\n  maybeConvertFromExportDeclaration(parentDeclar) {\n    const maybeExportDeclar = parentDeclar.parentPath;\n\n    if (!maybeExportDeclar.isExportDeclaration()) {\n      return;\n    }\n\n    if (maybeExportDeclar.isExportDefaultDeclaration() && !maybeExportDeclar.get(\"declaration\").node.id) {\n      return;\n    }\n\n    (0, _helperSplitExportDeclaration.default)(maybeExportDeclar);\n  }\n\n  maybeConvertFromClassFunctionDeclaration(path) {\n    return;\n    if (!path.isFunctionDeclaration() && !path.isClassDeclaration()) return;\n    if (this.binding.kind !== \"hoisted\") return;\n    path.node.id = t.identifier(this.oldName);\n    path.node._blockHoist = 3;\n    path.replaceWith(t.variableDeclaration(\"let\", [t.variableDeclarator(t.identifier(this.newName), t.toExpression(path.node))]));\n  }\n\n  maybeConvertFromClassFunctionExpression(path) {\n    return;\n    if (!path.isFunctionExpression() && !path.isClassExpression()) return;\n    if (this.binding.kind !== \"local\") return;\n    path.node.id = t.identifier(this.oldName);\n    this.binding.scope.parent.push({\n      id: t.identifier(this.newName)\n    });\n    path.replaceWith(t.assignmentExpression(\"=\", t.identifier(this.newName), path.node));\n  }\n\n  rename(block) {\n    const {\n      binding,\n      oldName,\n      newName\n    } = this;\n    const {\n      scope,\n      path\n    } = binding;\n    const parentDeclar = path.find(path => path.isDeclaration() || path.isFunctionExpression() || path.isClassExpression());\n\n    if (parentDeclar) {\n      const bindingIds = parentDeclar.getOuterBindingIdentifiers();\n\n      if (bindingIds[oldName] === binding.identifier) {\n        this.maybeConvertFromExportDeclaration(parentDeclar);\n      }\n    }\n\n    const blockToTraverse = block || scope.block;\n\n    if ((blockToTraverse == null ? void 0 : blockToTraverse.type) === \"SwitchStatement\") {\n      blockToTraverse.cases.forEach(c => {\n        scope.traverse(c, renameVisitor, this);\n      });\n    } else {\n      scope.traverse(blockToTraverse, renameVisitor, this);\n    }\n\n    if (!block) {\n      scope.removeOwnBinding(oldName);\n      scope.bindings[newName] = binding;\n      this.binding.identifier.name = newName;\n    }\n\n    if (parentDeclar) {\n      this.maybeConvertFromClassFunctionDeclaration(parentDeclar);\n      this.maybeConvertFromClassFunctionExpression(parentDeclar);\n    }\n  }\n\n}\n\nexports.default = Renamer;\n\nfunction skipAllButComputedMethodKey(path) {\n  if (!path.isMethod() || !path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = t.VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}"]},"metadata":{},"sourceType":"script"}