{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnaryExpression = UnaryExpression;\nexports.DoExpression = DoExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.NewExpression = NewExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ThisExpression = ThisExpression;\nexports.Super = Super;\nexports.Decorator = Decorator;\nexports.OptionalMemberExpression = OptionalMemberExpression;\nexports.OptionalCallExpression = OptionalCallExpression;\nexports.CallExpression = CallExpression;\nexports.Import = Import;\nexports.EmptyStatement = EmptyStatement;\nexports.ExpressionStatement = ExpressionStatement;\nexports.AssignmentPattern = AssignmentPattern;\nexports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;\nexports.BindExpression = BindExpression;\nexports.MemberExpression = MemberExpression;\nexports.MetaProperty = MetaProperty;\nexports.PrivateName = PrivateName;\nexports.V8IntrinsicIdentifier = V8IntrinsicIdentifier;\nexports.ModuleExpression = ModuleExpression;\nexports.AwaitExpression = exports.YieldExpression = void 0;\n\nvar t = require(\"@babel/types\");\n\nvar n = require(\"../node\");\n\nconst {\n  isCallExpression,\n  isLiteral,\n  isMemberExpression,\n  isNewExpression\n} = t;\n\nfunction UnaryExpression(node) {\n  if (node.operator === \"void\" || node.operator === \"delete\" || node.operator === \"typeof\" || node.operator === \"throw\") {\n    this.word(node.operator);\n    this.space();\n  } else {\n    this.token(node.operator);\n  }\n\n  this.print(node.argument, node);\n}\n\nfunction DoExpression(node) {\n  if (node.async) {\n    this.word(\"async\");\n    this.space();\n  }\n\n  this.word(\"do\");\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction ParenthesizedExpression(node) {\n  this.token(\"(\");\n  this.print(node.expression, node);\n  this.token(\")\");\n}\n\nfunction UpdateExpression(node) {\n  if (node.prefix) {\n    this.token(node.operator);\n    this.print(node.argument, node);\n  } else {\n    this.startTerminatorless(true);\n    this.print(node.argument, node);\n    this.endTerminatorless();\n    this.token(node.operator);\n  }\n}\n\nfunction ConditionalExpression(node) {\n  this.print(node.test, node);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.consequent, node);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.alternate, node);\n}\n\nfunction NewExpression(node, parent) {\n  this.word(\"new\");\n  this.space();\n  this.print(node.callee, node);\n\n  if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {\n    callee: node\n  }) && !isMemberExpression(parent) && !isNewExpression(parent)) {\n    return;\n  }\n\n  this.print(node.typeArguments, node);\n  this.print(node.typeParameters, node);\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  this.token(\"(\");\n  this.printList(node.arguments, node);\n  this.token(\")\");\n}\n\nfunction SequenceExpression(node) {\n  this.printList(node.expressions, node);\n}\n\nfunction ThisExpression() {\n  this.word(\"this\");\n}\n\nfunction Super() {\n  this.word(\"super\");\n}\n\nfunction Decorator(node) {\n  this.token(\"@\");\n  this.print(node.expression, node);\n  this.newline();\n}\n\nfunction OptionalMemberExpression(node) {\n  this.print(node.object, node);\n\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  let computed = node.computed;\n\n  if (isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  if (computed) {\n    this.token(\"[\");\n    this.print(node.property, node);\n    this.token(\"]\");\n  } else {\n    if (!node.optional) {\n      this.token(\".\");\n    }\n\n    this.print(node.property, node);\n  }\n}\n\nfunction OptionalCallExpression(node) {\n  this.print(node.callee, node);\n  this.print(node.typeArguments, node);\n  this.print(node.typeParameters, node);\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  this.token(\"(\");\n  this.printList(node.arguments, node);\n  this.token(\")\");\n}\n\nfunction CallExpression(node) {\n  this.print(node.callee, node);\n  this.print(node.typeArguments, node);\n  this.print(node.typeParameters, node);\n  this.token(\"(\");\n  this.printList(node.arguments, node);\n  this.token(\")\");\n}\n\nfunction Import() {\n  this.word(\"import\");\n}\n\nfunction buildYieldAwait(keyword) {\n  return function (node) {\n    this.word(keyword);\n\n    if (node.delegate) {\n      this.token(\"*\");\n    }\n\n    if (node.argument) {\n      this.space();\n      const terminatorState = this.startTerminatorless();\n      this.print(node.argument, node);\n      this.endTerminatorless(terminatorState);\n    }\n  };\n}\n\nconst YieldExpression = buildYieldAwait(\"yield\");\nexports.YieldExpression = YieldExpression;\nconst AwaitExpression = buildYieldAwait(\"await\");\nexports.AwaitExpression = AwaitExpression;\n\nfunction EmptyStatement() {\n  this.semicolon(true);\n}\n\nfunction ExpressionStatement(node) {\n  this.print(node.expression, node);\n  this.semicolon();\n}\n\nfunction AssignmentPattern(node) {\n  this.print(node.left, node);\n  if (node.left.optional) this.token(\"?\");\n  this.print(node.left.typeAnnotation, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right, node);\n}\n\nfunction AssignmentExpression(node, parent) {\n  const parens = this.inForStatementInitCounter && node.operator === \"in\" && !n.needsParens(node, parent);\n\n  if (parens) {\n    this.token(\"(\");\n  }\n\n  this.print(node.left, node);\n  this.space();\n\n  if (node.operator === \"in\" || node.operator === \"instanceof\") {\n    this.word(node.operator);\n  } else {\n    this.token(node.operator);\n  }\n\n  this.space();\n  this.print(node.right, node);\n\n  if (parens) {\n    this.token(\")\");\n  }\n}\n\nfunction BindExpression(node) {\n  this.print(node.object, node);\n  this.token(\"::\");\n  this.print(node.callee, node);\n}\n\nfunction MemberExpression(node) {\n  this.print(node.object, node);\n\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  let computed = node.computed;\n\n  if (isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n\n  if (computed) {\n    this.token(\"[\");\n    this.print(node.property, node);\n    this.token(\"]\");\n  } else {\n    this.token(\".\");\n    this.print(node.property, node);\n  }\n}\n\nfunction MetaProperty(node) {\n  this.print(node.meta, node);\n  this.token(\".\");\n  this.print(node.property, node);\n}\n\nfunction PrivateName(node) {\n  this.token(\"#\");\n  this.print(node.id, node);\n}\n\nfunction V8IntrinsicIdentifier(node) {\n  this.token(\"%\");\n  this.word(node.name);\n}\n\nfunction ModuleExpression(node) {\n  this.word(\"module\");\n  this.space();\n  this.token(\"{\");\n\n  if (node.body.body.length === 0) {\n    this.token(\"}\");\n  } else {\n    this.newline();\n    this.printSequence(node.body.body, node, {\n      indent: true\n    });\n    this.rightBrace();\n  }\n}","map":{"version":3,"sources":["/Users/alperenalkan/obss/frontend/frontend/node_modules/@babel/generator/lib/generators/expressions.js"],"names":["Object","defineProperty","exports","value","UnaryExpression","DoExpression","ParenthesizedExpression","UpdateExpression","ConditionalExpression","NewExpression","SequenceExpression","ThisExpression","Super","Decorator","OptionalMemberExpression","OptionalCallExpression","CallExpression","Import","EmptyStatement","ExpressionStatement","AssignmentPattern","LogicalExpression","BinaryExpression","AssignmentExpression","BindExpression","MemberExpression","MetaProperty","PrivateName","V8IntrinsicIdentifier","ModuleExpression","AwaitExpression","YieldExpression","t","require","n","isCallExpression","isLiteral","isMemberExpression","isNewExpression","node","operator","word","space","token","print","argument","async","body","expression","prefix","startTerminatorless","endTerminatorless","test","consequent","alternate","parent","callee","format","minified","arguments","length","optional","typeArguments","typeParameters","printList","expressions","newline","object","computed","property","TypeError","buildYieldAwait","keyword","delegate","terminatorState","semicolon","left","typeAnnotation","right","parens","inForStatementInitCounter","needsParens","meta","id","name","printSequence","indent","rightBrace"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UnaryExpression = UnaryExpression;\nexports.DoExpression = DoExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.NewExpression = NewExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.ThisExpression = ThisExpression;\nexports.Super = Super;\nexports.Decorator = Decorator;\nexports.OptionalMemberExpression = OptionalMemberExpression;\nexports.OptionalCallExpression = OptionalCallExpression;\nexports.CallExpression = CallExpression;\nexports.Import = Import;\nexports.EmptyStatement = EmptyStatement;\nexports.ExpressionStatement = ExpressionStatement;\nexports.AssignmentPattern = AssignmentPattern;\nexports.LogicalExpression = exports.BinaryExpression = exports.AssignmentExpression = AssignmentExpression;\nexports.BindExpression = BindExpression;\nexports.MemberExpression = MemberExpression;\nexports.MetaProperty = MetaProperty;\nexports.PrivateName = PrivateName;\nexports.V8IntrinsicIdentifier = V8IntrinsicIdentifier;\nexports.ModuleExpression = ModuleExpression;\nexports.AwaitExpression = exports.YieldExpression = void 0;\n\nvar t = require(\"@babel/types\");\n\nvar n = require(\"../node\");\n\nconst {\n  isCallExpression,\n  isLiteral,\n  isMemberExpression,\n  isNewExpression\n} = t;\n\nfunction UnaryExpression(node) {\n  if (node.operator === \"void\" || node.operator === \"delete\" || node.operator === \"typeof\" || node.operator === \"throw\") {\n    this.word(node.operator);\n    this.space();\n  } else {\n    this.token(node.operator);\n  }\n\n  this.print(node.argument, node);\n}\n\nfunction DoExpression(node) {\n  if (node.async) {\n    this.word(\"async\");\n    this.space();\n  }\n\n  this.word(\"do\");\n  this.space();\n  this.print(node.body, node);\n}\n\nfunction ParenthesizedExpression(node) {\n  this.token(\"(\");\n  this.print(node.expression, node);\n  this.token(\")\");\n}\n\nfunction UpdateExpression(node) {\n  if (node.prefix) {\n    this.token(node.operator);\n    this.print(node.argument, node);\n  } else {\n    this.startTerminatorless(true);\n    this.print(node.argument, node);\n    this.endTerminatorless();\n    this.token(node.operator);\n  }\n}\n\nfunction ConditionalExpression(node) {\n  this.print(node.test, node);\n  this.space();\n  this.token(\"?\");\n  this.space();\n  this.print(node.consequent, node);\n  this.space();\n  this.token(\":\");\n  this.space();\n  this.print(node.alternate, node);\n}\n\nfunction NewExpression(node, parent) {\n  this.word(\"new\");\n  this.space();\n  this.print(node.callee, node);\n\n  if (this.format.minified && node.arguments.length === 0 && !node.optional && !isCallExpression(parent, {\n    callee: node\n  }) && !isMemberExpression(parent) && !isNewExpression(parent)) {\n    return;\n  }\n\n  this.print(node.typeArguments, node);\n  this.print(node.typeParameters, node);\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  this.token(\"(\");\n  this.printList(node.arguments, node);\n  this.token(\")\");\n}\n\nfunction SequenceExpression(node) {\n  this.printList(node.expressions, node);\n}\n\nfunction ThisExpression() {\n  this.word(\"this\");\n}\n\nfunction Super() {\n  this.word(\"super\");\n}\n\nfunction Decorator(node) {\n  this.token(\"@\");\n  this.print(node.expression, node);\n  this.newline();\n}\n\nfunction OptionalMemberExpression(node) {\n  this.print(node.object, node);\n\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  let computed = node.computed;\n\n  if (isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  if (computed) {\n    this.token(\"[\");\n    this.print(node.property, node);\n    this.token(\"]\");\n  } else {\n    if (!node.optional) {\n      this.token(\".\");\n    }\n\n    this.print(node.property, node);\n  }\n}\n\nfunction OptionalCallExpression(node) {\n  this.print(node.callee, node);\n  this.print(node.typeArguments, node);\n  this.print(node.typeParameters, node);\n\n  if (node.optional) {\n    this.token(\"?.\");\n  }\n\n  this.token(\"(\");\n  this.printList(node.arguments, node);\n  this.token(\")\");\n}\n\nfunction CallExpression(node) {\n  this.print(node.callee, node);\n  this.print(node.typeArguments, node);\n  this.print(node.typeParameters, node);\n  this.token(\"(\");\n  this.printList(node.arguments, node);\n  this.token(\")\");\n}\n\nfunction Import() {\n  this.word(\"import\");\n}\n\nfunction buildYieldAwait(keyword) {\n  return function (node) {\n    this.word(keyword);\n\n    if (node.delegate) {\n      this.token(\"*\");\n    }\n\n    if (node.argument) {\n      this.space();\n      const terminatorState = this.startTerminatorless();\n      this.print(node.argument, node);\n      this.endTerminatorless(terminatorState);\n    }\n  };\n}\n\nconst YieldExpression = buildYieldAwait(\"yield\");\nexports.YieldExpression = YieldExpression;\nconst AwaitExpression = buildYieldAwait(\"await\");\nexports.AwaitExpression = AwaitExpression;\n\nfunction EmptyStatement() {\n  this.semicolon(true);\n}\n\nfunction ExpressionStatement(node) {\n  this.print(node.expression, node);\n  this.semicolon();\n}\n\nfunction AssignmentPattern(node) {\n  this.print(node.left, node);\n  if (node.left.optional) this.token(\"?\");\n  this.print(node.left.typeAnnotation, node);\n  this.space();\n  this.token(\"=\");\n  this.space();\n  this.print(node.right, node);\n}\n\nfunction AssignmentExpression(node, parent) {\n  const parens = this.inForStatementInitCounter && node.operator === \"in\" && !n.needsParens(node, parent);\n\n  if (parens) {\n    this.token(\"(\");\n  }\n\n  this.print(node.left, node);\n  this.space();\n\n  if (node.operator === \"in\" || node.operator === \"instanceof\") {\n    this.word(node.operator);\n  } else {\n    this.token(node.operator);\n  }\n\n  this.space();\n  this.print(node.right, node);\n\n  if (parens) {\n    this.token(\")\");\n  }\n}\n\nfunction BindExpression(node) {\n  this.print(node.object, node);\n  this.token(\"::\");\n  this.print(node.callee, node);\n}\n\nfunction MemberExpression(node) {\n  this.print(node.object, node);\n\n  if (!node.computed && isMemberExpression(node.property)) {\n    throw new TypeError(\"Got a MemberExpression for MemberExpression property\");\n  }\n\n  let computed = node.computed;\n\n  if (isLiteral(node.property) && typeof node.property.value === \"number\") {\n    computed = true;\n  }\n\n  if (computed) {\n    this.token(\"[\");\n    this.print(node.property, node);\n    this.token(\"]\");\n  } else {\n    this.token(\".\");\n    this.print(node.property, node);\n  }\n}\n\nfunction MetaProperty(node) {\n  this.print(node.meta, node);\n  this.token(\".\");\n  this.print(node.property, node);\n}\n\nfunction PrivateName(node) {\n  this.token(\"#\");\n  this.print(node.id, node);\n}\n\nfunction V8IntrinsicIdentifier(node) {\n  this.token(\"%\");\n  this.word(node.name);\n}\n\nfunction ModuleExpression(node) {\n  this.word(\"module\");\n  this.space();\n  this.token(\"{\");\n\n  if (node.body.body.length === 0) {\n    this.token(\"}\");\n  } else {\n    this.newline();\n    this.printSequence(node.body.body, node, {\n      indent: true\n    });\n    this.rightBrace();\n  }\n}"]},"metadata":{},"sourceType":"script"}