{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.skipAllButComputedKey = skipAllButComputedKey;\nexports.default = exports.environmentVisitor = void 0;\n\nvar _traverse = require(\"@babel/traverse\");\n\nvar _helperMemberExpressionToFunctions = require(\"@babel/helper-member-expression-to-functions\");\n\nvar _helperOptimiseCallExpression = require(\"@babel/helper-optimise-call-expression\");\n\nvar t = require(\"@babel/types\");\n\nfunction getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {\n  objectRef = t.cloneNode(objectRef);\n  const targetRef = isStatic || isPrivateMethod ? objectRef : t.memberExpression(objectRef, t.identifier(\"prototype\"));\n  return t.callExpression(file.addHelper(\"getPrototypeOf\"), [targetRef]);\n}\n\nfunction skipAllButComputedKey(path) {\n  if (!path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = t.VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}\n\nconst environmentVisitor = {\n  [`${t.staticBlock ? \"StaticBlock|\" : \"\"}ClassPrivateProperty|TypeAnnotation`](path) {\n    path.skip();\n  },\n\n  Function(path) {\n    if (path.isMethod()) return;\n    if (path.isArrowFunctionExpression()) return;\n    path.skip();\n  },\n\n  \"Method|ClassProperty\"(path) {\n    skipAllButComputedKey(path);\n  }\n\n};\nexports.environmentVisitor = environmentVisitor;\n\nconst visitor = _traverse.default.visitors.merge([environmentVisitor, {\n  Super(path, state) {\n    const {\n      node,\n      parentPath\n    } = path;\n    if (!parentPath.isMemberExpression({\n      object: node\n    })) return;\n    state.handle(parentPath);\n  }\n\n}]);\n\nconst unshadowSuperBindingVisitor = _traverse.default.visitors.merge([environmentVisitor, {\n  Scopable(path, {\n    refName\n  }) {\n    const binding = path.scope.getOwnBinding(refName);\n\n    if (binding && binding.identifier.name === refName) {\n      path.scope.rename(refName);\n    }\n  }\n\n}]);\n\nconst specHandlers = {\n  memoise(superMember, count) {\n    const {\n      scope,\n      node\n    } = superMember;\n    const {\n      computed,\n      property\n    } = node;\n\n    if (!computed) {\n      return;\n    }\n\n    const memo = scope.maybeGenerateMemoised(property);\n\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(property, memo, count);\n  },\n\n  prop(superMember) {\n    const {\n      computed,\n      property\n    } = superMember.node;\n\n    if (this.memoiser.has(property)) {\n      return t.cloneNode(this.memoiser.get(property));\n    }\n\n    if (computed) {\n      return t.cloneNode(property);\n    }\n\n    return t.stringLiteral(property.name);\n  },\n\n  get(superMember) {\n    return this._get(superMember, this._getThisRefs());\n  },\n\n  _get(superMember, thisRefs) {\n    const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);\n    return t.callExpression(this.file.addHelper(\"get\"), [thisRefs.memo ? t.sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), thisRefs.this]);\n  },\n\n  _getThisRefs() {\n    if (!this.isDerivedConstructor) {\n      return {\n        this: t.thisExpression()\n      };\n    }\n\n    const thisRef = this.scope.generateDeclaredUidIdentifier(\"thisSuper\");\n    return {\n      memo: t.assignmentExpression(\"=\", thisRef, t.thisExpression()),\n      this: t.cloneNode(thisRef)\n    };\n  },\n\n  set(superMember, value) {\n    const thisRefs = this._getThisRefs();\n\n    const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);\n    return t.callExpression(this.file.addHelper(\"set\"), [thisRefs.memo ? t.sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), value, thisRefs.this, t.booleanLiteral(superMember.isInStrictMode())]);\n  },\n\n  destructureSet(superMember) {\n    throw superMember.buildCodeFrameError(`Destructuring to a super field is not supported yet.`);\n  },\n\n  call(superMember, args) {\n    const thisRefs = this._getThisRefs();\n\n    return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), t.cloneNode(thisRefs.this), args, false);\n  },\n\n  optionalCall(superMember, args) {\n    const thisRefs = this._getThisRefs();\n\n    return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), t.cloneNode(thisRefs.this), args, true);\n  }\n\n};\nconst looseHandlers = Object.assign({}, specHandlers, {\n  prop(superMember) {\n    const {\n      property\n    } = superMember.node;\n\n    if (this.memoiser.has(property)) {\n      return t.cloneNode(this.memoiser.get(property));\n    }\n\n    return t.cloneNode(property);\n  },\n\n  get(superMember) {\n    const {\n      isStatic,\n      getSuperRef\n    } = this;\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    let object;\n\n    if (isStatic) {\n      var _getSuperRef;\n\n      object = (_getSuperRef = getSuperRef()) != null ? _getSuperRef : t.memberExpression(t.identifier(\"Function\"), t.identifier(\"prototype\"));\n    } else {\n      var _getSuperRef2;\n\n      object = t.memberExpression((_getSuperRef2 = getSuperRef()) != null ? _getSuperRef2 : t.identifier(\"Object\"), t.identifier(\"prototype\"));\n    }\n\n    return t.memberExpression(object, prop, computed);\n  },\n\n  set(superMember, value) {\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    return t.assignmentExpression(\"=\", t.memberExpression(t.thisExpression(), prop, computed), value);\n  },\n\n  destructureSet(superMember) {\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    return t.memberExpression(t.thisExpression(), prop, computed);\n  },\n\n  call(superMember, args) {\n    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), t.thisExpression(), args, false);\n  },\n\n  optionalCall(superMember, args) {\n    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), t.thisExpression(), args, true);\n  }\n\n});\n\nclass ReplaceSupers {\n  constructor(opts) {\n    var _opts$constantSuper;\n\n    const path = opts.methodPath;\n    this.methodPath = path;\n    this.isDerivedConstructor = path.isClassMethod({\n      kind: \"constructor\"\n    }) && !!opts.superRef;\n    this.isStatic = path.isObjectMethod() || path.node.static || (path.isStaticBlock == null ? void 0 : path.isStaticBlock());\n    this.isPrivateMethod = path.isPrivate() && path.isMethod();\n    this.file = opts.file;\n    this.constantSuper = (_opts$constantSuper = opts.constantSuper) != null ? _opts$constantSuper : opts.isLoose;\n    this.opts = opts;\n  }\n\n  getObjectRef() {\n    return t.cloneNode(this.opts.objectRef || this.opts.getObjectRef());\n  }\n\n  getSuperRef() {\n    if (this.opts.superRef) return t.cloneNode(this.opts.superRef);\n    if (this.opts.getSuperRef) return t.cloneNode(this.opts.getSuperRef());\n  }\n\n  replace() {\n    if (this.opts.refToPreserve) {\n      this.methodPath.traverse(unshadowSuperBindingVisitor, {\n        refName: this.opts.refToPreserve.name\n      });\n    }\n\n    const handler = this.constantSuper ? looseHandlers : specHandlers;\n    (0, _helperMemberExpressionToFunctions.default)(this.methodPath, visitor, Object.assign({\n      file: this.file,\n      scope: this.methodPath.scope,\n      isDerivedConstructor: this.isDerivedConstructor,\n      isStatic: this.isStatic,\n      isPrivateMethod: this.isPrivateMethod,\n      getObjectRef: this.getObjectRef.bind(this),\n      getSuperRef: this.getSuperRef.bind(this)\n    }, handler));\n  }\n\n}\n\nexports.default = ReplaceSupers;","map":{"version":3,"sources":["/Users/alperenalkan/obss/frontend/frontend/node_modules/@babel/helper-replace-supers/lib/index.js"],"names":["Object","defineProperty","exports","value","skipAllButComputedKey","default","environmentVisitor","_traverse","require","_helperMemberExpressionToFunctions","_helperOptimiseCallExpression","t","getPrototypeOfExpression","objectRef","isStatic","file","isPrivateMethod","cloneNode","targetRef","memberExpression","identifier","callExpression","addHelper","path","node","computed","skip","keys","VISITOR_KEYS","type","key","skipKey","staticBlock","Function","isMethod","isArrowFunctionExpression","visitor","visitors","merge","Super","state","parentPath","isMemberExpression","object","handle","unshadowSuperBindingVisitor","Scopable","refName","binding","scope","getOwnBinding","name","rename","specHandlers","memoise","superMember","count","property","memo","maybeGenerateMemoised","memoiser","set","prop","has","get","stringLiteral","_get","_getThisRefs","thisRefs","proto","getObjectRef","sequenceExpression","this","isDerivedConstructor","thisExpression","thisRef","generateDeclaredUidIdentifier","assignmentExpression","booleanLiteral","isInStrictMode","destructureSet","buildCodeFrameError","call","args","optionalCall","looseHandlers","assign","getSuperRef","_getSuperRef","_getSuperRef2","ReplaceSupers","constructor","opts","_opts$constantSuper","methodPath","isClassMethod","kind","superRef","isObjectMethod","static","isStaticBlock","isPrivate","constantSuper","isLoose","replace","refToPreserve","traverse","handler","bind"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.skipAllButComputedKey = skipAllButComputedKey;\nexports.default = exports.environmentVisitor = void 0;\n\nvar _traverse = require(\"@babel/traverse\");\n\nvar _helperMemberExpressionToFunctions = require(\"@babel/helper-member-expression-to-functions\");\n\nvar _helperOptimiseCallExpression = require(\"@babel/helper-optimise-call-expression\");\n\nvar t = require(\"@babel/types\");\n\nfunction getPrototypeOfExpression(objectRef, isStatic, file, isPrivateMethod) {\n  objectRef = t.cloneNode(objectRef);\n  const targetRef = isStatic || isPrivateMethod ? objectRef : t.memberExpression(objectRef, t.identifier(\"prototype\"));\n  return t.callExpression(file.addHelper(\"getPrototypeOf\"), [targetRef]);\n}\n\nfunction skipAllButComputedKey(path) {\n  if (!path.node.computed) {\n    path.skip();\n    return;\n  }\n\n  const keys = t.VISITOR_KEYS[path.type];\n\n  for (const key of keys) {\n    if (key !== \"key\") path.skipKey(key);\n  }\n}\n\nconst environmentVisitor = {\n  [`${t.staticBlock ? \"StaticBlock|\" : \"\"}ClassPrivateProperty|TypeAnnotation`](path) {\n    path.skip();\n  },\n\n  Function(path) {\n    if (path.isMethod()) return;\n    if (path.isArrowFunctionExpression()) return;\n    path.skip();\n  },\n\n  \"Method|ClassProperty\"(path) {\n    skipAllButComputedKey(path);\n  }\n\n};\nexports.environmentVisitor = environmentVisitor;\n\nconst visitor = _traverse.default.visitors.merge([environmentVisitor, {\n  Super(path, state) {\n    const {\n      node,\n      parentPath\n    } = path;\n    if (!parentPath.isMemberExpression({\n      object: node\n    })) return;\n    state.handle(parentPath);\n  }\n\n}]);\n\nconst unshadowSuperBindingVisitor = _traverse.default.visitors.merge([environmentVisitor, {\n  Scopable(path, {\n    refName\n  }) {\n    const binding = path.scope.getOwnBinding(refName);\n\n    if (binding && binding.identifier.name === refName) {\n      path.scope.rename(refName);\n    }\n  }\n\n}]);\n\nconst specHandlers = {\n  memoise(superMember, count) {\n    const {\n      scope,\n      node\n    } = superMember;\n    const {\n      computed,\n      property\n    } = node;\n\n    if (!computed) {\n      return;\n    }\n\n    const memo = scope.maybeGenerateMemoised(property);\n\n    if (!memo) {\n      return;\n    }\n\n    this.memoiser.set(property, memo, count);\n  },\n\n  prop(superMember) {\n    const {\n      computed,\n      property\n    } = superMember.node;\n\n    if (this.memoiser.has(property)) {\n      return t.cloneNode(this.memoiser.get(property));\n    }\n\n    if (computed) {\n      return t.cloneNode(property);\n    }\n\n    return t.stringLiteral(property.name);\n  },\n\n  get(superMember) {\n    return this._get(superMember, this._getThisRefs());\n  },\n\n  _get(superMember, thisRefs) {\n    const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);\n    return t.callExpression(this.file.addHelper(\"get\"), [thisRefs.memo ? t.sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), thisRefs.this]);\n  },\n\n  _getThisRefs() {\n    if (!this.isDerivedConstructor) {\n      return {\n        this: t.thisExpression()\n      };\n    }\n\n    const thisRef = this.scope.generateDeclaredUidIdentifier(\"thisSuper\");\n    return {\n      memo: t.assignmentExpression(\"=\", thisRef, t.thisExpression()),\n      this: t.cloneNode(thisRef)\n    };\n  },\n\n  set(superMember, value) {\n    const thisRefs = this._getThisRefs();\n\n    const proto = getPrototypeOfExpression(this.getObjectRef(), this.isStatic, this.file, this.isPrivateMethod);\n    return t.callExpression(this.file.addHelper(\"set\"), [thisRefs.memo ? t.sequenceExpression([thisRefs.memo, proto]) : proto, this.prop(superMember), value, thisRefs.this, t.booleanLiteral(superMember.isInStrictMode())]);\n  },\n\n  destructureSet(superMember) {\n    throw superMember.buildCodeFrameError(`Destructuring to a super field is not supported yet.`);\n  },\n\n  call(superMember, args) {\n    const thisRefs = this._getThisRefs();\n\n    return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), t.cloneNode(thisRefs.this), args, false);\n  },\n\n  optionalCall(superMember, args) {\n    const thisRefs = this._getThisRefs();\n\n    return (0, _helperOptimiseCallExpression.default)(this._get(superMember, thisRefs), t.cloneNode(thisRefs.this), args, true);\n  }\n\n};\nconst looseHandlers = Object.assign({}, specHandlers, {\n  prop(superMember) {\n    const {\n      property\n    } = superMember.node;\n\n    if (this.memoiser.has(property)) {\n      return t.cloneNode(this.memoiser.get(property));\n    }\n\n    return t.cloneNode(property);\n  },\n\n  get(superMember) {\n    const {\n      isStatic,\n      getSuperRef\n    } = this;\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    let object;\n\n    if (isStatic) {\n      var _getSuperRef;\n\n      object = (_getSuperRef = getSuperRef()) != null ? _getSuperRef : t.memberExpression(t.identifier(\"Function\"), t.identifier(\"prototype\"));\n    } else {\n      var _getSuperRef2;\n\n      object = t.memberExpression((_getSuperRef2 = getSuperRef()) != null ? _getSuperRef2 : t.identifier(\"Object\"), t.identifier(\"prototype\"));\n    }\n\n    return t.memberExpression(object, prop, computed);\n  },\n\n  set(superMember, value) {\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    return t.assignmentExpression(\"=\", t.memberExpression(t.thisExpression(), prop, computed), value);\n  },\n\n  destructureSet(superMember) {\n    const {\n      computed\n    } = superMember.node;\n    const prop = this.prop(superMember);\n    return t.memberExpression(t.thisExpression(), prop, computed);\n  },\n\n  call(superMember, args) {\n    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), t.thisExpression(), args, false);\n  },\n\n  optionalCall(superMember, args) {\n    return (0, _helperOptimiseCallExpression.default)(this.get(superMember), t.thisExpression(), args, true);\n  }\n\n});\n\nclass ReplaceSupers {\n  constructor(opts) {\n    var _opts$constantSuper;\n\n    const path = opts.methodPath;\n    this.methodPath = path;\n    this.isDerivedConstructor = path.isClassMethod({\n      kind: \"constructor\"\n    }) && !!opts.superRef;\n    this.isStatic = path.isObjectMethod() || path.node.static || (path.isStaticBlock == null ? void 0 : path.isStaticBlock());\n    this.isPrivateMethod = path.isPrivate() && path.isMethod();\n    this.file = opts.file;\n    this.constantSuper = (_opts$constantSuper = opts.constantSuper) != null ? _opts$constantSuper : opts.isLoose;\n    this.opts = opts;\n  }\n\n  getObjectRef() {\n    return t.cloneNode(this.opts.objectRef || this.opts.getObjectRef());\n  }\n\n  getSuperRef() {\n    if (this.opts.superRef) return t.cloneNode(this.opts.superRef);\n    if (this.opts.getSuperRef) return t.cloneNode(this.opts.getSuperRef());\n  }\n\n  replace() {\n    if (this.opts.refToPreserve) {\n      this.methodPath.traverse(unshadowSuperBindingVisitor, {\n        refName: this.opts.refToPreserve.name\n      });\n    }\n\n    const handler = this.constantSuper ? looseHandlers : specHandlers;\n    (0, _helperMemberExpressionToFunctions.default)(this.methodPath, visitor, Object.assign({\n      file: this.file,\n      scope: this.methodPath.scope,\n      isDerivedConstructor: this.isDerivedConstructor,\n      isStatic: this.isStatic,\n      isPrivateMethod: this.isPrivateMethod,\n      getObjectRef: this.getObjectRef.bind(this),\n      getSuperRef: this.getSuperRef.bind(this)\n    }, handler));\n  }\n\n}\n\nexports.default = ReplaceSupers;"]},"metadata":{},"sourceType":"script"}