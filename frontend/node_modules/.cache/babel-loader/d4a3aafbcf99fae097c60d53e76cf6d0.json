{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = require(\"./lib/hoister\");\n\nvar _index = require(\"./index\");\n\nvar t = require(\"@babel/types\");\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return t.isExpression(node) ? t.expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        t.assertExpression(node);\n        this.replaceWith(t.callExpression(t.arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", t.cloneNode(temp), node)));\n      nodes.push(t.expressionStatement(t.cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","map":{"version":3,"sources":["/Users/alperenalkan/obss/frontend/frontend/node_modules/@babel/traverse/lib/path/modification.js"],"names":["Object","defineProperty","exports","value","insertBefore","_containerInsert","_containerInsertBefore","_containerInsertAfter","insertAfter","updateSiblingKeys","_verifyNodeList","unshiftContainer","pushContainer","hoist","_cache","require","_hoister","_index","t","nodes_","_assertUnremoved","nodes","parentPath","isExpressionStatement","isLabeledStatement","isExportNamedDeclaration","isExportDefaultDeclaration","isDeclaration","isNodeType","isJSXElement","isForStatement","key","node","push","replaceExpressionWithStatements","Array","isArray","container","isStatementOrBlock","shouldInsertCurrentNode","expression","replaceWith","blockStatement","Error","from","length","paths","splice","i","to","path","getSibling","context","queue","pushContext","contexts","_getQueueContexts","setScope","debug","maybeQueue","map","isExpression","expressionStatement","scope","isPattern","assertExpression","callExpression","arrowFunctionExpression","get","isMethod","computed","parent","temp","generateDeclaredUidIdentifier","unshift","assignmentExpression","cloneNode","fromIndex","incrementBy","msg","type","default","listKey","setContext","verifiedNodes","replaceWithMultiple","hoister","run"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.insertBefore = insertBefore;\nexports._containerInsert = _containerInsert;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._containerInsertAfter = _containerInsertAfter;\nexports.insertAfter = insertAfter;\nexports.updateSiblingKeys = updateSiblingKeys;\nexports._verifyNodeList = _verifyNodeList;\nexports.unshiftContainer = unshiftContainer;\nexports.pushContainer = pushContainer;\nexports.hoist = hoist;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = require(\"./lib/hoister\");\n\nvar _index = require(\"./index\");\n\nvar t = require(\"@babel/types\");\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return t.isExpression(node) ? t.expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        t.assertExpression(node);\n        this.replaceWith(t.callExpression(t.arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(t.expressionStatement(t.assignmentExpression(\"=\", t.cloneNode(temp), node)));\n      nodes.push(t.expressionStatement(t.cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(t.blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}"]},"metadata":{},"sourceType":"script"}