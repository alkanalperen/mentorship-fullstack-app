{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = simplifyAccess;\n\nvar t = require(\"@babel/types\");\n\nfunction simplifyAccess(path, bindingNames) {\n  path.traverse(simpleAssignmentVisitor, {\n    scope: path.scope,\n    bindingNames,\n    seen: new WeakSet()\n  });\n}\n\nconst simpleAssignmentVisitor = {\n  UpdateExpression: {\n    exit(path) {\n      const {\n        scope,\n        bindingNames\n      } = this;\n      const arg = path.get(\"argument\");\n      if (!arg.isIdentifier()) return;\n      const localName = arg.node.name;\n      if (!bindingNames.has(localName)) return;\n\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n\n      if (path.parentPath.isExpressionStatement() && !path.isCompletionRecord()) {\n        const operator = path.node.operator == \"++\" ? \"+=\" : \"-=\";\n        path.replaceWith(t.assignmentExpression(operator, arg.node, t.numericLiteral(1)));\n      } else if (path.node.prefix) {\n        path.replaceWith(t.assignmentExpression(\"=\", t.identifier(localName), t.binaryExpression(path.node.operator[0], t.unaryExpression(\"+\", arg.node), t.numericLiteral(1))));\n      } else {\n        const old = path.scope.generateUidIdentifierBasedOnNode(arg.node, \"old\");\n        const varName = old.name;\n        path.scope.push({\n          id: old\n        });\n        const binary = t.binaryExpression(path.node.operator[0], t.identifier(varName), t.numericLiteral(1));\n        path.replaceWith(t.sequenceExpression([t.assignmentExpression(\"=\", t.identifier(varName), t.unaryExpression(\"+\", arg.node)), t.assignmentExpression(\"=\", t.cloneNode(arg.node), binary), t.identifier(varName)]));\n      }\n    }\n\n  },\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        bindingNames\n      } = this;\n      if (path.node.operator === \"=\") return;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      const left = path.get(\"left\");\n      if (!left.isIdentifier()) return;\n      const localName = left.node.name;\n      if (!bindingNames.has(localName)) return;\n\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n\n      const operator = path.node.operator.slice(0, -1);\n\n      if (t.LOGICAL_OPERATORS.includes(operator)) {\n        path.replaceWith(t.logicalExpression(operator, path.node.left, t.assignmentExpression(\"=\", t.cloneNode(path.node.left), path.node.right)));\n      } else {\n        path.node.right = t.binaryExpression(operator, t.cloneNode(path.node.left), path.node.right);\n        path.node.operator = \"=\";\n      }\n    }\n\n  }\n};","map":{"version":3,"sources":["/Users/alperenalkan/obss/frontend/frontend/node_modules/@babel/helper-simple-access/lib/index.js"],"names":["Object","defineProperty","exports","value","default","simplifyAccess","t","require","path","bindingNames","traverse","simpleAssignmentVisitor","scope","seen","WeakSet","UpdateExpression","exit","arg","get","isIdentifier","localName","node","name","has","getBinding","parentPath","isExpressionStatement","isCompletionRecord","operator","replaceWith","assignmentExpression","numericLiteral","prefix","identifier","binaryExpression","unaryExpression","old","generateUidIdentifierBasedOnNode","varName","push","id","binary","sequenceExpression","cloneNode","AssignmentExpression","add","left","slice","LOGICAL_OPERATORS","includes","logicalExpression","right"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = simplifyAccess;\n\nvar t = require(\"@babel/types\");\n\nfunction simplifyAccess(path, bindingNames) {\n  path.traverse(simpleAssignmentVisitor, {\n    scope: path.scope,\n    bindingNames,\n    seen: new WeakSet()\n  });\n}\n\nconst simpleAssignmentVisitor = {\n  UpdateExpression: {\n    exit(path) {\n      const {\n        scope,\n        bindingNames\n      } = this;\n      const arg = path.get(\"argument\");\n      if (!arg.isIdentifier()) return;\n      const localName = arg.node.name;\n      if (!bindingNames.has(localName)) return;\n\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n\n      if (path.parentPath.isExpressionStatement() && !path.isCompletionRecord()) {\n        const operator = path.node.operator == \"++\" ? \"+=\" : \"-=\";\n        path.replaceWith(t.assignmentExpression(operator, arg.node, t.numericLiteral(1)));\n      } else if (path.node.prefix) {\n        path.replaceWith(t.assignmentExpression(\"=\", t.identifier(localName), t.binaryExpression(path.node.operator[0], t.unaryExpression(\"+\", arg.node), t.numericLiteral(1))));\n      } else {\n        const old = path.scope.generateUidIdentifierBasedOnNode(arg.node, \"old\");\n        const varName = old.name;\n        path.scope.push({\n          id: old\n        });\n        const binary = t.binaryExpression(path.node.operator[0], t.identifier(varName), t.numericLiteral(1));\n        path.replaceWith(t.sequenceExpression([t.assignmentExpression(\"=\", t.identifier(varName), t.unaryExpression(\"+\", arg.node)), t.assignmentExpression(\"=\", t.cloneNode(arg.node), binary), t.identifier(varName)]));\n      }\n    }\n\n  },\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        bindingNames\n      } = this;\n      if (path.node.operator === \"=\") return;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      const left = path.get(\"left\");\n      if (!left.isIdentifier()) return;\n      const localName = left.node.name;\n      if (!bindingNames.has(localName)) return;\n\n      if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n        return;\n      }\n\n      const operator = path.node.operator.slice(0, -1);\n\n      if (t.LOGICAL_OPERATORS.includes(operator)) {\n        path.replaceWith(t.logicalExpression(operator, path.node.left, t.assignmentExpression(\"=\", t.cloneNode(path.node.left), path.node.right)));\n      } else {\n        path.node.right = t.binaryExpression(operator, t.cloneNode(path.node.left), path.node.right);\n        path.node.operator = \"=\";\n      }\n    }\n\n  }\n};"]},"metadata":{},"sourceType":"script"}