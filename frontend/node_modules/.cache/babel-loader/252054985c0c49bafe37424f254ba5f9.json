{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding != null && binding.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}","map":{"version":3,"sources":["/Users/alperenalkan/obss/frontend/frontend/node_modules/@babel/traverse/lib/path/evaluation.js"],"names":["Object","defineProperty","exports","value","evaluateTruthy","evaluate","VALID_CALLEES","INVALID_METHODS","res","confident","deopt","path","state","deoptPath","evaluateCached","node","seen","has","existing","get","resolved","item","set","val","_evaluate","isSequenceExpression","exprs","length","isStringLiteral","isNumericLiteral","isBooleanLiteral","isNullLiteral","isTemplateLiteral","evaluateQuasis","quasis","isTaggedTemplateExpression","isMemberExpression","object","name","property","isIdentifier","scope","getBinding","quasi","isConditionalExpression","testResult","isExpressionWrapper","parentPath","isCallExpression","callee","isLiteral","type","isReferencedIdentifier","binding","constantViolations","start","end","hasValue","undefined","Infinity","NaN","resolve","isUnaryExpression","prefix","operator","argument","isFunction","isClass","arg","isArrayExpression","arr","elems","elem","elemValue","push","isObjectExpression","obj","props","prop","isObjectMethod","isSpreadElement","keyPath","key","computed","valuePath","isLogicalExpression","wasConfident","left","leftConfident","right","rightConfident","isBinaryExpression","Math","pow","context","func","indexOf","global","args","map","apply","raw","str","i","cooked","expr","String","Map"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.evaluateTruthy = evaluateTruthy;\nexports.evaluate = evaluate;\nconst VALID_CALLEES = [\"String\", \"Number\", \"Math\"];\nconst INVALID_METHODS = [\"random\"];\n\nfunction evaluateTruthy() {\n  const res = this.evaluate();\n  if (res.confident) return !!res.value;\n}\n\nfunction deopt(path, state) {\n  if (!state.confident) return;\n  state.deoptPath = path;\n  state.confident = false;\n}\n\nfunction evaluateCached(path, state) {\n  const {\n    node\n  } = path;\n  const {\n    seen\n  } = state;\n\n  if (seen.has(node)) {\n    const existing = seen.get(node);\n\n    if (existing.resolved) {\n      return existing.value;\n    } else {\n      deopt(path, state);\n      return;\n    }\n  } else {\n    const item = {\n      resolved: false\n    };\n    seen.set(node, item);\n\n    const val = _evaluate(path, state);\n\n    if (state.confident) {\n      item.resolved = true;\n      item.value = val;\n    }\n\n    return val;\n  }\n}\n\nfunction _evaluate(path, state) {\n  if (!state.confident) return;\n\n  if (path.isSequenceExpression()) {\n    const exprs = path.get(\"expressions\");\n    return evaluateCached(exprs[exprs.length - 1], state);\n  }\n\n  if (path.isStringLiteral() || path.isNumericLiteral() || path.isBooleanLiteral()) {\n    return path.node.value;\n  }\n\n  if (path.isNullLiteral()) {\n    return null;\n  }\n\n  if (path.isTemplateLiteral()) {\n    return evaluateQuasis(path, path.node.quasis, state);\n  }\n\n  if (path.isTaggedTemplateExpression() && path.get(\"tag\").isMemberExpression()) {\n    const object = path.get(\"tag.object\");\n    const {\n      node: {\n        name\n      }\n    } = object;\n    const property = path.get(\"tag.property\");\n\n    if (object.isIdentifier() && name === \"String\" && !path.scope.getBinding(name) && property.isIdentifier() && property.node.name === \"raw\") {\n      return evaluateQuasis(path, path.node.quasi.quasis, state, true);\n    }\n  }\n\n  if (path.isConditionalExpression()) {\n    const testResult = evaluateCached(path.get(\"test\"), state);\n    if (!state.confident) return;\n\n    if (testResult) {\n      return evaluateCached(path.get(\"consequent\"), state);\n    } else {\n      return evaluateCached(path.get(\"alternate\"), state);\n    }\n  }\n\n  if (path.isExpressionWrapper()) {\n    return evaluateCached(path.get(\"expression\"), state);\n  }\n\n  if (path.isMemberExpression() && !path.parentPath.isCallExpression({\n    callee: path.node\n  })) {\n    const property = path.get(\"property\");\n    const object = path.get(\"object\");\n\n    if (object.isLiteral() && property.isIdentifier()) {\n      const value = object.node.value;\n      const type = typeof value;\n\n      if (type === \"number\" || type === \"string\") {\n        return value[property.node.name];\n      }\n    }\n  }\n\n  if (path.isReferencedIdentifier()) {\n    const binding = path.scope.getBinding(path.node.name);\n\n    if (binding && binding.constantViolations.length > 0) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding && path.node.start < binding.path.node.end) {\n      return deopt(binding.path, state);\n    }\n\n    if (binding != null && binding.hasValue) {\n      return binding.value;\n    } else {\n      if (path.node.name === \"undefined\") {\n        return binding ? deopt(binding.path, state) : undefined;\n      } else if (path.node.name === \"Infinity\") {\n        return binding ? deopt(binding.path, state) : Infinity;\n      } else if (path.node.name === \"NaN\") {\n        return binding ? deopt(binding.path, state) : NaN;\n      }\n\n      const resolved = path.resolve();\n\n      if (resolved === path) {\n        return deopt(path, state);\n      } else {\n        return evaluateCached(resolved, state);\n      }\n    }\n  }\n\n  if (path.isUnaryExpression({\n    prefix: true\n  })) {\n    if (path.node.operator === \"void\") {\n      return undefined;\n    }\n\n    const argument = path.get(\"argument\");\n\n    if (path.node.operator === \"typeof\" && (argument.isFunction() || argument.isClass())) {\n      return \"function\";\n    }\n\n    const arg = evaluateCached(argument, state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"!\":\n        return !arg;\n\n      case \"+\":\n        return +arg;\n\n      case \"-\":\n        return -arg;\n\n      case \"~\":\n        return ~arg;\n\n      case \"typeof\":\n        return typeof arg;\n    }\n  }\n\n  if (path.isArrayExpression()) {\n    const arr = [];\n    const elems = path.get(\"elements\");\n\n    for (const elem of elems) {\n      const elemValue = elem.evaluate();\n\n      if (elemValue.confident) {\n        arr.push(elemValue.value);\n      } else {\n        return deopt(elemValue.deopt, state);\n      }\n    }\n\n    return arr;\n  }\n\n  if (path.isObjectExpression()) {\n    const obj = {};\n    const props = path.get(\"properties\");\n\n    for (const prop of props) {\n      if (prop.isObjectMethod() || prop.isSpreadElement()) {\n        return deopt(prop, state);\n      }\n\n      const keyPath = prop.get(\"key\");\n      let key = keyPath;\n\n      if (prop.node.computed) {\n        key = key.evaluate();\n\n        if (!key.confident) {\n          return deopt(key.deopt, state);\n        }\n\n        key = key.value;\n      } else if (key.isIdentifier()) {\n        key = key.node.name;\n      } else {\n        key = key.node.value;\n      }\n\n      const valuePath = prop.get(\"value\");\n      let value = valuePath.evaluate();\n\n      if (!value.confident) {\n        return deopt(value.deopt, state);\n      }\n\n      value = value.value;\n      obj[key] = value;\n    }\n\n    return obj;\n  }\n\n  if (path.isLogicalExpression()) {\n    const wasConfident = state.confident;\n    const left = evaluateCached(path.get(\"left\"), state);\n    const leftConfident = state.confident;\n    state.confident = wasConfident;\n    const right = evaluateCached(path.get(\"right\"), state);\n    const rightConfident = state.confident;\n\n    switch (path.node.operator) {\n      case \"||\":\n        state.confident = leftConfident && (!!left || rightConfident);\n        if (!state.confident) return;\n        return left || right;\n\n      case \"&&\":\n        state.confident = leftConfident && (!left || rightConfident);\n        if (!state.confident) return;\n        return left && right;\n    }\n  }\n\n  if (path.isBinaryExpression()) {\n    const left = evaluateCached(path.get(\"left\"), state);\n    if (!state.confident) return;\n    const right = evaluateCached(path.get(\"right\"), state);\n    if (!state.confident) return;\n\n    switch (path.node.operator) {\n      case \"-\":\n        return left - right;\n\n      case \"+\":\n        return left + right;\n\n      case \"/\":\n        return left / right;\n\n      case \"*\":\n        return left * right;\n\n      case \"%\":\n        return left % right;\n\n      case \"**\":\n        return Math.pow(left, right);\n\n      case \"<\":\n        return left < right;\n\n      case \">\":\n        return left > right;\n\n      case \"<=\":\n        return left <= right;\n\n      case \">=\":\n        return left >= right;\n\n      case \"==\":\n        return left == right;\n\n      case \"!=\":\n        return left != right;\n\n      case \"===\":\n        return left === right;\n\n      case \"!==\":\n        return left !== right;\n\n      case \"|\":\n        return left | right;\n\n      case \"&\":\n        return left & right;\n\n      case \"^\":\n        return left ^ right;\n\n      case \"<<\":\n        return left << right;\n\n      case \">>\":\n        return left >> right;\n\n      case \">>>\":\n        return left >>> right;\n    }\n  }\n\n  if (path.isCallExpression()) {\n    const callee = path.get(\"callee\");\n    let context;\n    let func;\n\n    if (callee.isIdentifier() && !path.scope.getBinding(callee.node.name) && VALID_CALLEES.indexOf(callee.node.name) >= 0) {\n      func = global[callee.node.name];\n    }\n\n    if (callee.isMemberExpression()) {\n      const object = callee.get(\"object\");\n      const property = callee.get(\"property\");\n\n      if (object.isIdentifier() && property.isIdentifier() && VALID_CALLEES.indexOf(object.node.name) >= 0 && INVALID_METHODS.indexOf(property.node.name) < 0) {\n        context = global[object.node.name];\n        func = context[property.node.name];\n      }\n\n      if (object.isLiteral() && property.isIdentifier()) {\n        const type = typeof object.node.value;\n\n        if (type === \"string\" || type === \"number\") {\n          context = object.node.value;\n          func = context[property.node.name];\n        }\n      }\n    }\n\n    if (func) {\n      const args = path.get(\"arguments\").map(arg => evaluateCached(arg, state));\n      if (!state.confident) return;\n      return func.apply(context, args);\n    }\n  }\n\n  deopt(path, state);\n}\n\nfunction evaluateQuasis(path, quasis, state, raw = false) {\n  let str = \"\";\n  let i = 0;\n  const exprs = path.get(\"expressions\");\n\n  for (const elem of quasis) {\n    if (!state.confident) break;\n    str += raw ? elem.value.raw : elem.value.cooked;\n    const expr = exprs[i++];\n    if (expr) str += String(evaluateCached(expr, state));\n  }\n\n  if (!state.confident) return;\n  return str;\n}\n\nfunction evaluate() {\n  const state = {\n    confident: true,\n    deoptPath: null,\n    seen: new Map()\n  };\n  let value = evaluateCached(this, state);\n  if (!state.confident) value = undefined;\n  return {\n    confident: state.confident,\n    deopt: state.deoptPath,\n    value: value\n  };\n}"]},"metadata":{},"sourceType":"script"}